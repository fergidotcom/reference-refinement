<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Reference Refinement v16.6</title>
    <script src="https://unpkg.com/dropbox@10.34.0/dist/Dropbox-sdk.min.js"></script>
    <style>
        /* CSS Variables */
        :root {
            --primary-color: #2c3e50;
            --accent-color: #3498db;
            --success-color: #27ae60;
            --danger-color: #e74c3c;
            --warning-color: #f39c12;
            --background: #f5f7fa;
            --card-background: #ffffff;
            --text-primary: #2c3e50;
            --text-secondary: #7f8c8d;
            --border-color: #dcdfe6;
            --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.1);
            --shadow-md: 0 4px 8px rgba(0, 0, 0, 0.15);
            --shadow-lg: 0 8px 16px rgba(0, 0, 0, 0.2);
            --tab-active: #3498db;
            --tab-inactive: #95a5a6;
        }

        /* Reset & Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
            background: var(--background);
            color: var(--text-primary);
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Header */
        .header {
            background: var(--primary-color);
            color: white;
            padding: 0.75rem 1rem;
            box-shadow: var(--shadow-md);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .header h1 {
            font-size: 1.4rem;
            font-weight: 600;
            letter-spacing: -0.5px;
        }

        .header-controls {
            display: flex;
            gap: 0.75rem;
            align-items: center;
            flex-wrap: wrap;
        }

        /* Mode Toggle */
        .mode-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            padding: 0.25rem;
        }

        .mode-label {
            font-size: 0.85rem;
            opacity: 0.9;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 13px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 22px;
            height: 22px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
            box-shadow: var(--shadow-sm);
        }

        .toggle-switch.active {
            background: var(--accent-color);
        }

        .toggle-switch.active .toggle-slider {
            transform: translateX(24px);
        }

        /* API Status */
        .api-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.4rem 0.8rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-secondary);
        }

        .status-indicator.connected { background: var(--success-color); }
        .status-indicator.error { background: var(--danger-color); }

        /* API Config Panel */
        .api-config {
            background: var(--card-background);
            padding: 1rem;
            border-bottom: 2px solid var(--border-color);
            display: none;
        }

        .api-config.visible { display: block; }

        .api-config-inner {
            max-width: 800px;
            margin: 0 auto;
        }

        .api-input-group {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .api-input {
            flex: 1;
            padding: 0.6rem;
            border: 2px solid var(--border-color);
            border-radius: 6px;
            font-size: 0.95rem;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
        }

        .api-input:focus {
            outline: none;
            border-color: var(--accent-color);
        }

        /* Buttons */
        button {
            padding: 0.5rem 1rem;
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }

        button:hover {
            background: #2980b9;
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        button:active { transform: translateY(0); }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button.secondary {
            background: var(--text-secondary);
        }

        button.success {
            background: var(--success-color);
        }

        button.danger {
            background: var(--danger-color);
        }

        /* Main Container */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 1rem;
        }

        /* Controls Section */
        .controls {
            background: var(--card-background);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            box-shadow: var(--shadow-sm);
        }

        .control-row {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .control-row:last-child { margin-bottom: 0; }

        .control-group {
            flex: 1;
            min-width: 200px;
        }

        .control-group label {
            display: block;
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
            font-weight: 500;
        }

        .control-input {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 0.95rem;
        }

        .control-input:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }

        /* Stats Bar */
        .stats-bar {
            display: flex;
            gap: 2rem;
            padding: 0.75rem 1rem;
            background: linear-gradient(90deg, var(--primary-color), #34495e);
            color: white;
            border-radius: 6px;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
        }

        .stat-label {
            font-size: 0.75rem;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-size: 1.2rem;
            font-weight: 600;
        }

        /* Reference Grid */
        .references-grid {
            display: grid;
            gap: 1rem;
        }

        /* Reference Card */
        .reference-card {
            background: var(--card-background);
            border-radius: 8px;
            padding: 1rem;
            box-shadow: var(--shadow-sm);
            transition: all 0.2s;
            border: 2px solid transparent;
            overflow-wrap: break-word;
            word-wrap: break-word;
            word-break: break-word;
            max-width: 100%;
            overflow-x: hidden;
        }

        .reference-card * {
            overflow-wrap: break-word;
            word-wrap: break-word;
            max-width: 100%;
        }

        .reference-card:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
            border-color: var(--accent-color);
        }

        .reference-card.finalized {
            background: #e8f5e9;
            border-color: var(--success-color);
        }

        .reference-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 0.75rem;
            gap: 1rem;
        }

        .reference-id {
            background: var(--primary-color);
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-weight: 600;
            font-size: 0.85rem;
        }

        .finalized-badge {
            background: var(--success-color);
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .override-badge {
            background: var(--warning-color);
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .reference-content h3 {
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
            color: var(--primary-color);
            overflow-wrap: break-word;
            word-wrap: break-word;
        }

        .reference-authors {
            font-size: 0.95rem;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
            overflow-wrap: break-word;
            word-wrap: break-word;
        }

        .reference-year {
            display: inline-block;
            background: var(--background);
            padding: 0.15rem 0.5rem;
            border-radius: 4px;
            font-size: 0.85rem;
            margin-bottom: 0.5rem;
        }

        .reference-relevance {
            margin-top: 0.5rem;
            padding: 0.5rem;
            background: #fff9e6;
            border-left: 3px solid var(--warning-color);
            color: var(--text-secondary);
            font-size: 0.9rem;
            font-style: italic;
            border-radius: 4px;
            overflow-wrap: break-word;
            word-break: break-word;
        }

        .reference-meta {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
            overflow-wrap: break-word;
            word-break: break-all; /* Force long URLs to break */
        }

        .reference-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            flex-wrap: wrap;
        }

        .reference-actions button {
            font-size: 0.85rem;
            padding: 0.4rem 0.8rem;
        }

        /* URLs Section */
        .urls-section {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border-color);
        }

        .url-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            background: var(--background);
            border-radius: 4px;
            margin-bottom: 0.5rem;
        }

        .url-type {
            font-size: 0.75rem;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            background: var(--primary-color);
            color: white;
            text-transform: uppercase;
            font-weight: 600;
        }

        .url-type.primary { background: var(--success-color); }
        .url-type.secondary { background: var(--accent-color); }

        .url-link {
            flex: 1;
            color: var(--accent-color);
            text-decoration: none;
            font-size: 0.9rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .url-link:hover { text-decoration: underline; }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.75);
            z-index: 1000;
            padding: 1rem;
            overflow-y: auto;
            align-items: center;
            justify-content: center;
        }

        .modal.visible { display: flex; }

        .modal-content {
            background: #ffffff;
            border-radius: 12px;
            width: 100%;
            max-width: 900px;
            margin: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            border: 1px solid var(--border-color);
            opacity: 1;
            overflow: hidden;
        }

        .modal-header {
            padding: 0.75rem;
            border-bottom: 2px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: var(--primary-color);
        }

        .modal-close {
            width: 32px;
            height: 32px;
            background: transparent;
            border: none;
            font-size: 1.5rem;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-close:hover {
            background: var(--background);
            color: var(--text-primary);
        }

        /* Tabs */
        .modal-tabs {
            display: flex;
            border-bottom: 2px solid var(--border-color);
            background: var(--background);
        }

        .modal-tab {
            flex: 1;
            padding: 1rem;
            background: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-weight: 500;
            color: var(--text-secondary);
            transition: all 0.2s;
        }

        .modal-tab:hover {
            background: rgba(52, 152, 219, 0.1);
            transform: none;
            box-shadow: none;
        }

        .modal-tab.active {
            color: var(--tab-active);
            border-bottom-color: var(--tab-active);
            background: var(--card-background);
        }

        .modal-body {
            padding: 0.75rem;
            overflow-y: auto;
            overflow-x: hidden;
            flex: 1;
            background: #ffffff;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        #tab1.tab-content.active {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .modal-section {
            margin-bottom: 0.75rem;
        }

        .modal-section:last-child { margin-bottom: 0; }

        .modal-section h3 {
            font-size: 1rem;
            margin-bottom: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .modal-footer {
            padding: 1rem 1.5rem;
            border-top: 2px solid var(--border-color);
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
        }

        /* Form Elements */
        .form-group {
            margin-bottom: 1rem;
        }

        .form-label {
            display: block;
            font-size: 0.9rem;
            font-weight: 500;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }

        .form-input,
        .form-textarea,
        .form-select {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid var(--border-color);
            border-radius: 6px;
            font-size: 0.95rem;
            transition: border-color 0.2s;
        }

        .form-textarea {
            min-height: 120px;
            resize: vertical;
            font-family: inherit;
        }

        .form-input:focus,
        .form-textarea:focus,
        .form-select:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }

        .form-select {
            background: white;
            cursor: pointer;
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        /* Candidates List */
        .candidates-list {
            min-height: 600px;
            max-height: 700px;
            overflow-y: auto;
        }

        .candidate-item {
            display: flex;
            gap: 0.75rem;
            padding: 0.75rem;
            margin-bottom: 0.75rem;
            background: var(--background);
            border-radius: 6px;
            border: 2px solid transparent;
            transition: all 0.2s;
            align-items: stretch;
        }

        .candidate-item:hover {
            border-color: var(--accent-color);
        }

        .candidate-item.selected-primary {
            border-color: var(--success-color);
            background: #e8f5e9;
        }

        .candidate-item.selected-secondary {
            border-color: var(--accent-color);
            background: #e8f4fd;
        }

        .candidate-buttons {
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
            flex-shrink: 0;
        }

        .candidate-buttons button {
            font-size: 0.75rem;
            padding: 0.4rem 0.6rem;
            white-space: nowrap;
            min-width: 100px;
        }

        .candidate-content {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .candidate-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 0.3rem;
        }

        .candidate-title {
            font-weight: 600;
            color: var(--primary-color);
            flex: 1;
            margin-right: 0.5rem;
            font-size: 0.95rem;
            line-height: 1.3;
        }

        .candidate-score {
            background: var(--warning-color);
            color: white;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .candidate-snippet {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 0.3rem;
            line-height: 1.4;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }

        .candidate-url {
            font-size: 0.8rem;
            color: var(--accent-color);
            word-break: break-all;
            cursor: pointer;
            text-decoration: none;
        }

        .candidate-url:hover {
            text-decoration: underline;
        }

        .candidate-actions {
            display: flex;
            gap: 0.5rem;
        }

        .candidate-actions button {
            font-size: 0.8rem;
            padding: 0.3rem 0.6rem;
        }

        /* Debug Section */
        .debug-section {
            background: #f8f9fa;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .debug-label {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
            text-transform: uppercase;
        }

        .debug-content {
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 0.85rem;
            white-space: pre-wrap;
            word-break: break-all;
            color: var(--text-primary);
        }

        /* Debug Panels */
        .debug-panels-container {
            overflow-y: auto;
            max-height: 600px;
            padding: 0.5rem;
        }

        .debug-panel {
            background: var(--background);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            margin-bottom: 1rem;
            overflow: hidden;
        }

        .debug-panel-header {
            background: var(--primary-color);
            color: white;
            padding: 0.75rem 1rem;
            font-weight: 600;
            font-size: 0.9rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .debug-panel-timestamp {
            font-size: 0.8rem;
            opacity: 0.9;
        }

        .debug-panel-content {
            padding: 1rem;
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 0.85rem;
            white-space: pre-wrap;
            word-break: break-word;
            line-height: 1.5;
        }

        .debug-panel-content strong {
            color: var(--primary-color);
        }

        .debug-panel.error .debug-panel-header {
            background: var(--error-color);
        }

        .debug-panel.success .debug-panel-header {
            background: var(--success-color);
        }

        .debug-panel.warning .debug-panel-header {
            background: var(--warning-color);
        }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            top: 5rem;  /* v14.1: Moved from bottom to avoid obscuring buttons */
            right: 2rem;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            pointer-events: none;
        }

        .toast {
            background: var(--primary-color);
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            box-shadow: var(--shadow-lg);
            transform: translateX(400px);
            transition: transform 0.3s;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.75rem;
            max-width: 400px;
            min-width: 300px;
        }

        .toast.visible { transform: translateX(0); }
        .toast.success { background: var(--success-color); }
        .toast.error { background: var(--danger-color); }
        .toast.warning { background: var(--warning-color); }

        .toast-message {
            flex: 1;
        }

        .toast-close {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            line-height: 1;
            cursor: pointer;
            opacity: 0.8;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity 0.2s;
            flex-shrink: 0;
        }

        .toast-close:hover {
            opacity: 1;
        }

        /* Loading States */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Mobile Styles */
        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                align-items: stretch;
            }

            .header h1 {
                font-size: 1.2rem;
                text-align: center;
            }

            .header-controls {
                justify-content: center;
            }

            .control-row {
                flex-direction: column;
            }

            .control-group {
                min-width: 100%;
            }

            .stats-bar {
                justify-content: space-around;
            }

            .modal-content {
                margin: 0.5rem;
                max-height: calc(100vh - 1rem);
            }

            .toast-container {
                left: 1rem;
                right: 1rem;
                top: 4rem;  /* v14.1: Consistent with desktop positioning */
            }

            .toast {
                max-width: 100%;
            }

            .form-row {
                grid-template-columns: 1fr;
            }

            .modal-tabs {
                flex-direction: column;
            }
        }

        /* Print Styles */
        @media print {
            .header,
            .controls,
            .reference-actions,
            .modal,
            .toast-container {
                display: none !important;
            }

            .reference-card {
                page-break-inside: avoid;
                box-shadow: none;
                border: 1px solid #ddd;
            }
        }

        /* Accessibility */
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Focus Indicators */
        *:focus-visible {
            outline: 3px solid var(--accent-color);
            outline-offset: 2px;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--background);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--text-secondary);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary-color);
        }

        /* v16.5: Quick Note Modal */
        .quick-note-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .quick-note-modal.show {
            display: flex;
        }

        .quick-note-content {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .quick-note-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 2px solid var(--accent-color);
        }

        .quick-note-header h3 {
            margin: 0;
            font-size: 1.1rem;
            color: var(--primary-color);
        }

        .quick-note-textarea {
            width: 100%;
            min-height: 150px;
            padding: 0.75rem;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            font-size: 0.95rem;
            resize: vertical;
            margin-bottom: 1rem;
        }

        .quick-note-textarea:focus {
            outline: none;
            border-color: var(--accent-color);
        }

        .quick-note-actions {
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="header-content">
            <h1>Reference Refinement v16.6</h1>
            <button onclick="app.showQuickNote()" class="secondary" style="margin-left: 1rem; font-size: 0.85rem; padding: 0.5rem 1rem;">
                üìù Quick Note
            </button>
        </div>
    </header>

    <!-- Main Container -->
    <div class="container">
        <!-- File Controls -->
        <div class="controls">
            <div class="control-row">
                <div class="control-group">
                    <label>Load References (decisions.txt)</label>
                    <input type="file" id="fileInput" accept=".txt" onchange="app.loadFile(event, 'decisions')">
                </div>
                <div class="control-group">
                    <label>AI Model (for Suggest Queries & AutoRank)</label>
                    <select id="aiModelSelect" class="form-select" onchange="app.saveModelPreference()">
                        <option value="claude-3-5-haiku-20241022">Claude Haiku (Fast & Economical)</option>
                        <option value="claude-sonnet-4-20250514" selected>Claude Sonnet 4 (Best Quality)</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Display Filters</label>
                    <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                        <label style="display: flex; align-items: center; gap: 0.3rem; cursor: pointer;">
                            <input type="checkbox" id="showFinalizedToggle" onchange="app.applyFilters()" checked>
                            <span>Show Finalized References</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 0.3rem; cursor: pointer;">
                            <input type="checkbox" id="showManualReviewToggle" onchange="app.applyFilters()" checked>
                            <span>Show Manual Review Needed</span>
                        </label>
                    </div>
                </div>
                <div class="control-group">
                    <label>Dropbox</label>
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                        <button onclick="app.connectDropbox()" id="dropboxConnectBtn" class="secondary">
                            Connect to Dropbox
                        </button>
                        <span id="dropboxStatus" style="font-size: 0.85rem; color: var(--text-secondary);">Not connected</span>
                    </div>
                </div>
                <div class="control-group">
                    <label>Session Log</label>
                    <div style="display: flex; gap: 0.5rem;">
                        <button onclick="app.saveSessionLogToDropbox()" id="saveLogBtn" class="secondary" disabled>
                            Save Session Log to Dropbox
                        </button>
                        <button onclick="app.clearSessionLog()" class="secondary" style="background: var(--danger-color);">
                            Clear Log
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Statistics Bar -->
        <div class="stats-bar">
            <div class="stat-item">
                <span class="stat-label">Total</span>
                <span id="statTotal" class="stat-value">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Filtered</span>
                <span id="statFiltered" class="stat-value">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">With URLs</span>
                <span id="statUrls" class="stat-value">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Finalized</span>
                <span id="statFinalized" class="stat-value">0</span>
            </div>
            <div class="stat-item" style="color: #f39c12;">
                <span class="stat-label">AI Overrides</span>
                <span id="statOverrides" class="stat-value">0</span>
            </div>
        </div>

        <!-- References Grid -->
        <div id="referencesGrid" class="references-grid">
            <!-- References will be inserted here -->
        </div>
    </div>

    <!-- Edit Modal with Tabs -->
    <div id="editModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <div style="flex: 1;">
                    <h2 id="modalTitle" class="modal-title">Edit Reference</h2>
                    <div id="modalReferenceInfo" style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 0.25rem; line-height: 1.3;">
                        <!-- Reference title and author will be displayed here -->
                    </div>
                </div>
                <button onclick="app.showQuickNote()" class="secondary" style="margin-right: 0.5rem; font-size: 0.85rem; padding: 0.5rem 1rem;">
                    üìù Quick Note
                </button>
                <button class="modal-close" onclick="app.closeModal()">&times;</button>
            </div>

            <!-- Tabs -->
            <div class="modal-tabs">
                <button class="modal-tab active" onclick="app.switchTab(0)">
                    Suggest & Query
                </button>
                <button class="modal-tab" onclick="app.switchTab(1)">
                    Candidates & Autorank
                </button>
                <button class="modal-tab" onclick="app.switchTab(2)">
                    Debug & Feedback
                </button>
            </div>

            <div class="modal-body">
                <!-- Tab 1: Suggest & Query -->
                <div id="tab0" class="tab-content active">
                    <div class="modal-section" style="padding: 0.5rem 0.75rem; margin-bottom: 0.5rem;">
                        <div class="form-row" style="grid-template-columns: 80px 1fr;">
                            <div class="form-group" style="margin-bottom: 0.5rem;">
                                <input id="editId" type="text" class="form-input" readonly placeholder="RID">
                            </div>
                            <div class="form-group" style="margin-bottom: 0.5rem;">
                                <input id="editTitle" type="text" class="form-input" placeholder="Title">
                            </div>
                        </div>

                        <div class="form-row">
                            <div class="form-group" style="margin-bottom: 0.5rem;">
                                <input id="editAuthors" type="text" class="form-input" placeholder="Authors">
                            </div>
                            <div class="form-group" style="margin-bottom: 0.5rem;">
                                <input id="editYear" type="text" class="form-input" placeholder="Year">
                            </div>
                        </div>

                        <div class="form-group" style="margin-bottom: 0.5rem;">
                            <input id="editOther" type="text" class="form-input"
                                placeholder="Other: Vol. 45(3), pp. 123-145, DOI: 10.xxxx/..., ISBN: 978..., Location: NY">
                        </div>

                        <!-- Hidden fields for backward compatibility -->
                        <input id="editVolume" type="hidden">
                        <input id="editIssue" type="hidden">
                        <input id="editPages" type="hidden">
                        <input id="editEdition" type="hidden">
                        <input id="editDOI" type="hidden">
                        <input id="editISBN" type="hidden">
                        <input id="editPublisherPlace" type="hidden">
                    </div>

                    <div class="modal-section" style="padding: 0.5rem 0.75rem; margin-bottom: 0.5rem;">
                        <div class="form-group" style="margin-bottom: 0.35rem;">
                            <input id="editPrimaryUrl" type="url" class="form-input" placeholder="Primary URL: https://...">
                        </div>
                        <div class="form-group" style="margin-bottom: 0.35rem;">
                            <input id="editSecondaryUrl" type="url" class="form-input" placeholder="Secondary URL: https://...">
                        </div>
                    </div>

                    <!-- Hidden relevance text field for backend use -->
                    <textarea id="editRelevanceText" style="display: none;"></textarea>

                    <div class="modal-section" style="padding: 0.5rem 0.75rem; margin-bottom: 0.5rem;">
                        <!-- v14.3: Simple Queries Toggle -->
                        <div class="form-group" style="margin-bottom: 0.5rem; padding: 0.5rem; background: var(--background); border-radius: 6px; border: 1px solid var(--border-color);">
                            <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; user-select: none;">
                                <input type="checkbox" id="simpleQueriesToggle" onchange="app.toggleSimpleQueries()"
                                       style="width: 18px; height: 18px; cursor: pointer;">
                                <div style="flex: 1;">
                                    <div style="font-weight: 600; font-size: 0.9rem;">Simple Queries (3 queries)</div>
                                    <div style="font-size: 0.8rem; color: var(--text-muted); line-height: 1.3;">
                                        Faster, lower cost. Uses: Title+Author, Book Review, Topic Keywords
                                    </div>
                                </div>
                            </label>
                            <div id="simpleQueriesInfo" style="margin-top: 0.5rem; padding: 0.5rem; background: var(--info-bg, #e3f2fd); border-left: 3px solid var(--info-color, #2196f3); font-size: 0.85rem; display: none;">
                                <strong>Simple Mode:</strong> Generates 3 focused queries (vs. 8 comprehensive queries). Best for straightforward references.
                            </div>
                        </div>

                        <div class="form-group" style="margin-bottom: 0.5rem;">
                            <label class="form-label" style="margin-bottom: 0.25rem;">Generated Queries</label>
                            <textarea id="editQueries" class="form-textarea" rows="5"
                                placeholder="Click 'Suggest' to generate queries, or enter manually (one per line)..."></textarea>
                        </div>
                        <div style="display: flex; gap: 0.5rem;">
                            <button onclick="app.generateQueries()">
                                <span id="suggestBtnText">Suggest Queries (AI)</span>
                            </button>
                            <button onclick="app.runSearch()" class="success">
                                <span id="queryBtnText">Query & Search</span>
                            </button>
                            <button onclick="app.showQuickNote()" style="background: #9b59b6;">
                                üìù Note
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Tab 2: Candidates & Autorank -->
                <div id="tab1" class="tab-content">
                    <div class="modal-section" style="flex: 1; overflow: hidden; display: flex; flex-direction: column; padding: 0.5rem 0.75rem;">
                        <!-- Sort Toggle -->
                        <div id="sortToggleContainer" style="display: none; margin-bottom: 0.75rem; padding: 0.5rem; background: var(--background); border-radius: 6px;">
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <span style="font-size: 0.85rem; font-weight: 600; color: var(--text-secondary);">Sort by:</span>
                                <div style="display: flex; gap: 0.25rem; background: white; border-radius: 6px; padding: 0.25rem; border: 1px solid var(--border-color);">
                                    <button id="sortByPrimary" onclick="app.setSortFocus('primary')" style="padding: 0.4rem 1rem; border: none; border-radius: 4px; font-size: 0.85rem; cursor: pointer; font-weight: 600; background: var(--accent-color); color: white; transition: all 0.2s;">
                                        Primary Score
                                    </button>
                                    <button id="sortBySecondary" onclick="app.setSortFocus('secondary')" style="padding: 0.4rem 1rem; border: none; border-radius: 4px; font-size: 0.85rem; cursor: pointer; font-weight: 600; background: transparent; color: var(--text-secondary); transition: all 0.2s;">
                                        Secondary Score
                                    </button>
                                </div>
                            </div>
                        </div>

                        <div id="candidatesContainer" style="flex: 1; overflow-y: auto; min-height: 300px; max-height: 450px;">
                            <p style="color: var(--text-secondary); text-align: center; padding: 2rem;">
                                No search results yet. Run queries in the "Suggest & Query" tab first.
                            </p>
                        </div>
                    </div>

                    <div class="modal-section" style="flex-shrink: 0; padding: 0.5rem 0.75rem; margin-bottom: 0.5rem;">
                        <div id="currentUrlsDisplay" style="padding: 0.5rem; background: var(--background); border-radius: 6px; font-size: 0.85rem;">
                            <div style="margin-bottom: 0.25rem;">
                                <strong>Primary:</strong> <span id="displayPrimaryUrl" style="color: var(--text-secondary); font-style: italic;">Not set</span>
                            </div>
                            <div>
                                <strong>Secondary:</strong> <span id="displaySecondaryUrl" style="color: var(--text-secondary); font-style: italic;">Not set</span>
                            </div>
                        </div>
                    </div>

                    <div class="modal-section" style="flex-shrink: 0; padding: 0.5rem 0.75rem;">
                        <h3 style="margin-bottom: 0.5rem;">Actions</h3>
                        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                            <button onclick="app.rankCandidates()">
                                <span id="rankBtnText">Autorank Candidates (AI)</span>
                            </button>
                            <button onclick="app.showQuickNote()" style="background: #9b59b6;">
                                üìù Note
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Tab 3: Debug & Feedback -->
                <div id="tab2" class="tab-content" style="display: flex; flex-direction: column; overflow: hidden;">
                    <!-- User Notes Panel (Always Visible) -->
                    <div style="padding: 0.75rem; background: #fffbea; border-bottom: 2px solid var(--warning-color); flex-shrink: 0;">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.5rem;">
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <span style="font-size: 1.2rem;">üìù</span>
                                <h4 style="margin: 0; font-size: 0.9rem; color: var(--warning-color);">Your Notes</h4>
                            </div>
                            <button onclick="app.saveQuickNoteWithContext()" class="primary" style="font-size: 0.75rem; padding: 0.35rem 0.75rem;">
                                Save Note Now
                            </button>
                        </div>
                        <textarea id="userNotesTextarea"
                            placeholder="Type observations, questions, or notes here. Click 'Save Note Now' to save with full context..."
                            style="width: 100%; height: 80px; font-family: -apple-system, BlinkMacSystemFont, sans-serif;
                                   font-size: 0.85rem; padding: 0.5rem; border: 1px solid var(--warning-color);
                                   border-radius: 4px; background: white; resize: vertical;"></textarea>
                    </div>

                    <!-- Session Cost Tracker -->
                    <div id="sessionCostDisplay" style="padding: 0.75rem; background: #e3f2fd; border-bottom: 2px solid var(--accent-color); flex-shrink: 0;">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.5rem;">
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <span style="font-size: 1.2rem;">üí∞</span>
                                <h4 style="margin: 0; font-size: 0.9rem; color: var(--accent-color);">Session Cost Tracker</h4>
                            </div>
                            <button onclick="app.resetSessionCosts()" class="secondary" style="font-size: 0.75rem; padding: 0.25rem 0.5rem;">
                                Reset
                            </button>
                        </div>
                        <div style="font-size: 0.8rem; font-family: monospace; line-height: 1.6;">
                            <div style="display: grid; grid-template-columns: 1fr auto; gap: 0.5rem;">
                                <span>Google Searches:</span><span id="costGoogleSearches">0</span>
                                <span>Claude Query Gen:</span><span id="costClaudeQueryGen">0 calls</span>
                                <span>Claude Ranking:</span><span id="costClaudeRank">0 calls</span>
                                <div style="grid-column: 1 / -1; height: 1px; background: var(--border-color); margin: 0.25rem 0;"></div>
                                <span><strong>Google Cost:</strong></span><span id="costGoogle"><strong>$0.0000</strong></span>
                                <span><strong>Claude Cost:</strong></span><span id="costClaude"><strong>$0.0000</strong></span>
                                <div style="grid-column: 1 / -1; height: 1px; background: var(--accent-color); margin: 0.25rem 0;"></div>
                                <span><strong>Total Session:</strong></span><span id="costTotal"><strong>$0.0000</strong></span>
                            </div>
                        </div>
                    </div>

                    <div id="debugPanelsContainer" class="debug-panels-container" style="flex: 1; overflow-y: auto;">
                        <!-- Panels will be dynamically added here -->
                    </div>

                    <div style="padding: 0.5rem 0.75rem; border-top: 2px solid var(--border-color); background: var(--background);">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                            <h4 style="margin: 0; font-size: 0.9rem;">Full Session Log (Copy/Paste to Save)</h4>
                            <button onclick="app.copySessionLog()" class="secondary" style="font-size: 0.8rem; padding: 0.3rem 0.6rem;">
                                Copy to Clipboard
                            </button>
                        </div>
                        <textarea id="sessionLogTextarea" readonly
                            style="width: 100%; height: 120px; font-family: monospace; font-size: 0.75rem;
                                   padding: 0.5rem; border: 1px solid var(--border-color); border-radius: 4px;
                                   background: #f8f9fa; resize: vertical;"
                            placeholder="Session log will appear here as you work..."></textarea>
                    </div>
                </div>
            </div>

            <div class="modal-footer">
                <button onclick="app.doneEditing()" class="secondary">Done</button>
                <button onclick="app.saveReference()" class="success">Save Changes</button>
                <button onclick="app.finalizeReference()" style="background: var(--warning-color);">Finalize</button>
            </div>
        </div>
    </div>

    <!-- Override Annotation Modal -->
    <div id="overrideModal" class="modal" style="z-index: 1100;">
        <div class="modal-content" style="max-width: 600px; background: var(--card-background);">
            <div class="modal-header">
                <h2 class="modal-title">Why Did You Make This Change?</h2>
                <button class="modal-close" onclick="app.closeOverrideModal(false)">&times;</button>
            </div>
            <div class="modal-body">
                <div class="modal-section">
                    <div id="overrideDetails" style="background: var(--background); padding: 1rem; border-radius: 6px; margin-bottom: 1rem; font-size: 0.9rem;"></div>
                    <div class="form-group">
                        <label class="form-label">Your explanation (optional but encouraged):</label>
                        <textarea id="overrideAnnotation" class="form-textarea" rows="4"
                            placeholder="Example: 'AI query was too generic, needed to focus on the MAGA context' or 'University press is more authoritative than Wikipedia for academic work'"></textarea>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button onclick="app.closeOverrideModal(false)" class="secondary">Skip</button>
                <button onclick="app.closeOverrideModal(true)" class="success">Log & Continue</button>
            </div>
        </div>
    </div>

    <!-- Auto-save Indicator -->
    <div id="autoSaveIndicator" style="position: fixed; bottom: 20px; right: 20px; background: var(--success-color); color: white; padding: 0.5rem 1rem; border-radius: 6px; box-shadow: var(--shadow-md); opacity: 0; transition: opacity 0.3s; pointer-events: none; z-index: 2000;">
        ‚úì Auto-saved
    </div>

    <!-- Toast Container -->
    <div id="toastContainer" class="toast-container"></div>

    <!-- JavaScript Application -->
    <script>
        // Application State
        const app = {
            references: [],
            finalizedReferences: [],
            filteredReferences: [],
            currentEditId: null,
            currentTab: 0,
            apiBaseUrl: '',
            debugPanels: [],  // Array of debug panels for current reference
            currentSystemLogPanel: null,  // Track current system log panel for consolidation
            overrideLog: [],  // Track query and ranking overrides
            aiSuggestedQuery: null,  // Store AI-suggested query for comparison
            aiRankedResults: null,  // Store AI ranking results for comparison
            autoSaveTimeout: null,  // Debounce timer for auto-save
            userNoteTimeout: null,  // Debounce timer for user notes
            sortFocus: 'primary',  // Track sort mode: 'primary' or 'secondary'

            // v14.3: Simple queries mode (3 queries vs 8 queries)
            simpleQueries: false,

            // Cost tracking
            sessionCosts: {
                googleSearches: 0,
                claudeQueryGenCalls: 0,
                claudeQueryGenTokensIn: 0,
                claudeQueryGenTokensOut: 0,
                claudeRankCalls: 0,
                claudeRankTokensIn: 0,
                claudeRankTokensOut: 0
            },

            // Dropbox integration
            dropboxAppKey: 'q4ldgkwjmhxv6w2',
            dropboxAccessToken: null,
            dropboxRefreshToken: null,
            dropboxTokenExpiry: null,
            dropboxClient: null,

            // Initialize
            async init() {
                console.log('[INIT] Starting application initialization...');

                // Check for OAuth callback
                await this.handleDropboxOAuthCallback();

                // Load Dropbox tokens
                this.dropboxAccessToken = localStorage.getItem('rr_dropbox_token');
                this.dropboxRefreshToken = localStorage.getItem('rr_dropbox_refresh_token');
                const expiryStr = localStorage.getItem('rr_dropbox_token_expiry');
                this.dropboxTokenExpiry = expiryStr ? parseInt(expiryStr) : null;

                console.log('[INIT] Dropbox token:', this.dropboxAccessToken ? 'Found' : 'Not found');
                console.log('[INIT] Refresh token:', this.dropboxRefreshToken ? 'Found' : 'Not found');

                if (this.dropboxAccessToken) {
                    // Check if token needs refresh
                    await this.ensureValidDropboxToken();
                    this.initializeDropbox(this.dropboxAccessToken);
                    console.log('[INIT] Dropbox client initialized');
                }

                // Load override log from localStorage
                const savedLog = localStorage.getItem('rr_override_log');
                if (savedLog) {
                    try {
                        this.overrideLog = JSON.parse(savedLog);
                    } catch (e) {
                        this.overrideLog = [];
                    }
                }

                // Try to load decisions.txt from Dropbox first, fallback to localStorage
                if (this.dropboxClient) {
                    console.log('[INIT] Attempting to load decisions.txt from Dropbox...');
                    try {
                        const content = await this.loadFromDropbox('/decisions.txt');
                        if (content) {
                            console.log('[INIT] Loaded decisions.txt from Dropbox, size:', content.length);
                            try {
                                this.parseDecisions(content);
                                this.applyFilters();

                                // Update localStorage with fresh Dropbox data
                                localStorage.setItem('rr_decisions_backup', content);
                                localStorage.setItem('rr_decisions_timestamp', new Date().toISOString());

                                this.showToast('Auto-loaded from Dropbox', 'success');
                                console.log('[INIT] Successfully parsed and displayed decisions.txt from Dropbox');
                                return; // Success, exit early
                            } catch (e) {
                                console.error('[INIT] Failed to parse Dropbox content:', e);
                                console.error('[INIT] Error stack:', e.stack);
                                console.error('[INIT] First 500 chars of content:', content.substring(0, 500));
                                this.showToast(`Failed to parse Dropbox file: ${e.message}`, 'error');
                                // Try to continue with empty references rather than completely failing
                                this.references = [];
                            }
                        } else {
                            console.log('[INIT] No content returned from Dropbox (file may not exist)');
                        }
                    } catch (e) {
                        console.error('[INIT] Error loading from Dropbox:', e);
                    }
                }

                // Fallback to localStorage if Dropbox failed or not connected
                console.log('[INIT] Falling back to localStorage...');
                const savedDecisions = localStorage.getItem('rr_decisions_backup');
                const savedTimestamp = localStorage.getItem('rr_decisions_timestamp');
                if (savedDecisions) {
                    try {
                        this.parseDecisions(savedDecisions);
                        this.applyFilters();
                        const timestamp = savedTimestamp ? new Date(savedTimestamp).toLocaleString() : 'Unknown';
                        this.showToast(`Auto-loaded backup from ${timestamp}`, 'success');
                        console.log('[INIT] Successfully auto-loaded from localStorage');
                    } catch (e) {
                        console.error('[INIT] Failed to auto-load from localStorage:', e);
                    }
                } else {
                    console.log('[INIT] No backup found in localStorage');
                }

                // Load saved AI model preference (default to Sonnet 4)
                const savedModel = localStorage.getItem('rr_ai_model') || 'claude-sonnet-4-20250514';
                const modelSelect = document.getElementById('aiModelSelect');
                if (modelSelect) {
                    modelSelect.value = savedModel;
                }

                // Setup event listeners
                this.setupEventListeners();
            },

            // Event Listeners
            setupEventListeners() {
                // Close modal on ESC
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') this.closeModal();
                });

                // Close modal on background click
                document.getElementById('editModal').addEventListener('click', (e) => {
                    if (e.target.id === 'editModal') this.closeModal();
                });
            },


            // API Client
            async apiRequest(endpoint, options = {}) {
                // When in standalone mode (no custom backend), use absolute Netlify URL
                // because the HTML may be served from claude.ai artifacts
                const NETLIFY_URL = 'https://rrv521-1760738877.netlify.app';

                let url;
                if (this.apiBaseUrl) {
                    // Advanced mode - use custom backend
                    url = `${this.apiBaseUrl}${endpoint}`;
                } else {
                    // Standalone mode - use absolute Netlify URL
                    // Convert /api/ to /.netlify/functions/
                    const functionPath = endpoint.replace('/api/', '/');
                    url = `${NETLIFY_URL}/.netlify/functions${functionPath}`;
                }

                const defaultOptions = {
                    headers: {
                        'Content-Type': 'application/json',
                    }
                };

                try {
                    console.log('API Request:', url, options);
                    const response = await fetch(url, { ...defaultOptions, ...options });

                    console.log('API Response status:', response.status);

                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error('API Error response:', errorText);
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const data = await response.json();
                    console.log('API Response data:', data);
                    return data;
                } catch (error) {
                    console.error('API request failed:', error);
                    throw error;
                }
            },


            // File Operations
            loadFile(event, fileType) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        if (fileType === 'decisions') {
                            this.parseDecisions(e.target.result);
                            this.showToast(`Loaded ${this.references.length} references`, 'success');
                        } else if (fileType === 'final') {
                            this.parseFinal(e.target.result);
                            this.showToast(`Loaded ${this.finalizedReferences.length} finalized references`, 'success');
                        }
                        this.applyFilters();
                    } catch (error) {
                        this.showToast('Failed to parse file', 'error');
                        console.error('Parse error:', error);
                    }
                };
                reader.readAsText(file);
            },

            parseDecisions(content) {
                this.references = [];

                // Detect format by checking first reference line
                const firstRefLine = content.split('\n').find(line => line.match(/^\[\d+\]/));
                const isNewFormat = firstRefLine && (firstRefLine.includes('FLAGS[') || firstRefLine.includes('PRIMARY_URL[') || firstRefLine.includes('Relevance:'));

                console.log('[PARSE] Format detection:', isNewFormat ? 'SINGLE-LINE (v14.7+)' : 'MULTI-LINE (legacy)');
                console.log('[PARSE] First reference line sample:', firstRefLine ? firstRefLine.substring(0, 150) + '...' : 'NOT FOUND');

                if (isNewFormat) {
                    // Use new single-line format parser with error handling (v15.3)
                    console.log('[PARSE] Using single-line parser with extractReferenceInfo()');
                    const lines = content.split('\n');
                    let parseErrors = 0;

                    for (const line of lines) {
                        const trimmed = line.trim();
                        if (trimmed.startsWith('[') && trimmed.match(/^\[\d+\]/)) {
                            const idMatch = trimmed.match(/\[(\d+)\]/);
                            if (idMatch) {
                                const ref = {
                                    id: idMatch[1],
                                    text: trimmed,
                                    finalized: false,
                                    relevance_text: '',
                                    urls: { primary: '', secondary: '', tertiary: '' },
                                    queries: [],
                                    searchResults: [],
                                    title: '', authors: '', year: '',
                                    container_title: '', publisher: '', publisher_place: '',
                                    volume: '', issue: '', pages: '', edition: '',
                                    doi: '', isbn: '', needsManualReview: false
                                };

                                try {
                                    // Parse single-line format using extractReferenceInfo
                                    this.extractReferenceInfo(ref);
                                    this.references.push(ref);
                                } catch (error) {
                                    console.error(`[PARSE] Failed to parse reference [${ref.id}]:`, error);
                                    console.error('[PARSE] Problem line:', trimmed.substring(0, 200));
                                    console.error('[PARSE] Error details:', error.message, error.stack);
                                    parseErrors++;
                                    // Continue parsing other references
                                }
                            }
                        }
                    }

                    console.log(`[PARSE] Single-line parsing complete: ${this.references.length} references loaded, ${parseErrors} errors`);

                    if (parseErrors > 0) {
                        console.warn(`[PARSE] Completed with ${parseErrors} errors. ${this.references.length} references loaded successfully.`);
                        this.showToast(`Loaded ${this.references.length} refs (${parseErrors} skipped due to errors)`, 'warning');
                    } else {
                        console.log('[PARSE] All references parsed successfully!');
                    }

                    return;
                }

                // OLD multi-line format parser (fallback for compatibility)
                const lines = content.split('\n');
                let currentRef = null;

                for (const line of lines) {
                    const trimmed = line.trim();

                    // Reference ID line
                    if (trimmed.startsWith('[') && trimmed.includes(']') && trimmed.match(/\[\d+\]/)) {
                        if (currentRef) this.references.push(currentRef);

                        const idMatch = trimmed.match(/\[(\d+)\]/);
                        if (idMatch) {
                            currentRef = {
                                id: idMatch[1],
                                text: trimmed,
                                finalized: false,
                                relevance_text: '',
                                urls: {
                                    primary: '',
                                    secondary: '',
                                    tertiary: ''
                                    },
                                queries: [],
                                searchResults: [],
                                // Bibliographic fields
                                title: '',
                                authors: '',
                                year: '',
                                container_title: '',
                                publisher: '',
                                publisher_place: '',
                                volume: '',
                                issue: '',
                                pages: '',
                                edition: '',
                                doi: '',
                                isbn: ''
                            };

                            // Extract basic info
                            this.extractReferenceInfo(currentRef);
                        }
                    }
                    // FINALIZED flag
                    else if (trimmed === '[FINALIZED]' && currentRef) {
                        currentRef.finalized = true;
                    }
                    // URL lines
                    else if (trimmed.startsWith('Primary URL:') && currentRef) {
                        currentRef.urls.primary = trimmed.replace('Primary URL:', '').trim();
                    }
                    else if (trimmed.startsWith('Secondary URL:') && currentRef) {
                        currentRef.urls.secondary = trimmed.replace('Secondary URL:', '').trim();
                    }
                    // Relevance text (not a rating)
                    else if (trimmed.startsWith('Relevance:') && currentRef) {
                        const relevanceText = trimmed.replace('Relevance:', '').trim();
                        // Only store if it's not a rating keyword
                        if (!['high', 'medium', 'low', 'remove', 'unknown'].includes(relevanceText.toLowerCase())) {
                            currentRef.relevance_text = relevanceText;
                        }
                    }
                    // Query lines
                    else if (trimmed.startsWith('Q:') && currentRef) {
                        currentRef.queries.push(trimmed.substring(2).trim());
                    }
                }

                if (currentRef) this.references.push(currentRef);
            },

            parseFinal(content) {
                this.finalizedReferences = [];
                const lines = content.split('\n');
                let currentRef = null;

                for (const line of lines) {
                    const trimmed = line.trim();

                    if (trimmed.startsWith('[') && trimmed.includes(']')) {
                        if (currentRef) this.finalizedReferences.push(currentRef);

                        const idMatch = trimmed.match(/\[(\d+)\]/);
                        if (idMatch) {
                            currentRef = {
                                id: idMatch[1],
                                text: trimmed,
                                finalized: true,
                                relevance_text: '',
                                urls: { primary: '', secondary: '', tertiary: '' },
                                queries: [],
                                searchResults: [],
                                title: '', authors: '', year: '',
                                container_title: '', publisher: '', publisher_place: '',
                                volume: '', issue: '', pages: '', edition: '',
                                doi: '', isbn: ''
                            };
                            this.extractReferenceInfo(currentRef);
                        }
                    }
                    else if (trimmed.startsWith('Primary URL:') && currentRef) {
                        currentRef.urls.primary = trimmed.replace('Primary URL:', '').trim();
                    }
                    else if (trimmed.startsWith('Secondary URL:') && currentRef) {
                        currentRef.urls.secondary = trimmed.replace('Secondary URL:', '').trim();
                    }
                    // Relevance text
                    else if (trimmed.startsWith('Relevance:') && currentRef) {
                        const relevanceText = trimmed.replace('Relevance:', '').trim();
                        if (!['high', 'medium', 'low', 'remove', 'unknown'].includes(relevanceText.toLowerCase())) {
                            currentRef.relevance_text = relevanceText;
                        }
                    }
                }

                if (currentRef) this.finalizedReferences.push(currentRef);

                // Merge finalized references into main references
                for (const finalRef of this.finalizedReferences) {
                    const existingRef = this.references.find(r => r.id === finalRef.id);
                    if (existingRef) {
                        existingRef.finalized = true;
                        existingRef.urls = finalRef.urls;
                    } else {
                        this.references.push(finalRef);
                    }
                }
            },

            extractReferenceInfo(ref) {
                // Simplified parser - only extract RID, Authors, Year, Title
                // Everything else goes in "Other" field
                // Format: [RID] Authors (Year). Title. Other bibliographic info. Relevance: text FLAGS[...] URLs[...]

                const text = ref.text;

                // 1. Find "Relevance:" as anchor point
                const relevanceIndex = text.indexOf('Relevance:');

                // 2. Extract bibliographic section (everything before "Relevance:")
                let biblioSection = '';
                if (relevanceIndex > 0) {
                    // Remove [RID] from start to get pure biblio section
                    biblioSection = text.substring(0, relevanceIndex).replace(/^\[\d+\]\s*/, '').trim();
                } else {
                    // No "Relevance:" found - treat everything except FLAGS/URLs as biblio
                    const flagsIndex = text.indexOf('FLAGS[');
                    const urlIndex = text.indexOf('PRIMARY_URL[');
                    const endIndex = flagsIndex > 0 ? flagsIndex : (urlIndex > 0 ? urlIndex : text.length);
                    biblioSection = text.substring(0, endIndex).replace(/^\[\d+\]\s*/, '').trim();
                }

                // 3. Extract relevance text (between "Relevance:" and FLAGS/URLs/EOL)
                if (relevanceIndex > 0) {
                    const afterRelevance = text.substring(relevanceIndex + 10); // Skip "Relevance:"
                    const flagsMatch = afterRelevance.match(/^(.*?)(?=FLAGS\[|PRIMARY_URL\[|SECONDARY_URL\[|$)/);
                    ref.relevance_text = flagsMatch ? flagsMatch[1].trim() : afterRelevance.trim();
                } else {
                    // v15.6: Extract unlabeled relevance text
                    // Rule: Everything after bibliographic info and before FLAGS is relevance text
                    const flagsIndex = text.indexOf('FLAGS[');
                    const urlIndex = text.indexOf('PRIMARY_URL[');
                    const endIndex = flagsIndex > 0 ? flagsIndex : (urlIndex > 0 ? urlIndex : text.length);

                    // Remove [RID] from start
                    let afterRid = text.substring(0, endIndex).replace(/^\[\d+\]\s*/, '').trim();

                    // Find the END of bibliographic info by looking for common publication end markers
                    const pubEndPatterns = [
                        /(?:Press|Publications?|University|Institute|Foundation|Bureau|Center|Centre)\./i,
                        /ISBN[:\s]+[\dXx\-]+/i,
                        /DOI[:\s]+[\d\.\/]+/i,
                        /pp?\.\s*\d+[\-‚Äì]\d+/i,
                        /Vol\.\s*\d+,?\s*No\.\s*\d+/i
                    ];

                    let relevanceStartIndex = -1;
                    for (const pattern of pubEndPatterns) {
                        const match = afterRid.match(pattern);
                        if (match) {
                            const matchEnd = match.index + match[0].length;
                            if (matchEnd > relevanceStartIndex) {
                                relevanceStartIndex = matchEnd;
                            }
                        }
                    }

                    // If we found a publication end marker, extract everything after it as relevance
                    if (relevanceStartIndex > 0 && relevanceStartIndex < afterRid.length) {
                        const potentialRelevance = afterRid.substring(relevanceStartIndex).trim();
                        // Only use if it's substantial (more than a few words)
                        if (potentialRelevance.length > 20) {
                            ref.relevance_text = potentialRelevance;
                        }
                    }
                }

                // 4. Extract FLAGS
                const flagsMatch = text.match(/FLAGS\[([^\]]*)\]/);
                if (flagsMatch) {
                    const flagsContent = flagsMatch[1];
                    // v16.0: Split on spaces (not commas) to match batch-utils.js format
                    const flags = flagsContent.split(/\s+/).map(f => f.trim()).filter(f => f);
                    ref.finalized = flags.includes('FINALIZED');
                    ref.needsManualReview = flags.includes('MANUAL_REVIEW');
                    // v16.0: Extract BATCH version (e.g., BATCH_v16.0)
                    const batchFlag = flags.find(f => f.startsWith('BATCH_'));
                    ref.batchVersion = batchFlag ? batchFlag.replace('BATCH_', '') : null;
                } else {
                    ref.finalized = false;
                    ref.needsManualReview = false;
                    ref.batchVersion = null;
                }

                // 5. Extract URLs - v15.1: Robust extraction without unescaping (file has plain URLs)
                // Match from PRIMARY_URL[ to next ] followed by space or another field or end of string
                const primaryUrlMatch = text.match(/PRIMARY_URL\[(.*?)\](?:\s|$)/);
                if (primaryUrlMatch) {
                    ref.urls.primary = primaryUrlMatch[1].trim();
                }

                const secondaryUrlMatch = text.match(/SECONDARY_URL\[(.*?)\](?:\s|$)/);
                if (secondaryUrlMatch) {
                    ref.urls.secondary = secondaryUrlMatch[1].trim();
                }

                const tertiaryUrlMatch = text.match(/TERTIARY_URL\[(.*?)\](?:\s|$)/);
                if (tertiaryUrlMatch) {
                    ref.urls.tertiary = tertiaryUrlMatch[1].trim();
                }

                // 6. Parse only RID, Authors, Year, Title - everything else is "Other"
                this.parseSimplifiedBiblio(ref, biblioSection);

                // 7. Debug logging for v15.3 (optional - can remove if too verbose)
                if (ref.id === '1' || ref.id === '100' || ref.id === '110') {
                    console.log(`[PARSE] Sample ref [${ref.id}]: finalized=${ref.finalized}, needsManualReview=${ref.needsManualReview}, primary=${ref.urls.primary ? 'YES' : 'NO'}, secondary=${ref.urls.secondary ? 'YES' : 'NO'}`);
                }
            },

            cleanTitle(title) {
                // Clean common title parsing errors
                // Removes date prefixes, trailing dots, and publisher contamination
                if (!title) return '';

                let cleaned = title;

                // Remove date prefix patterns: "November 10) " or "January 31, 2024) " or "September) "
                const datePrefix = /^(January|February|March|April|May|June|July|August|September|October|November|December)(?:\s+\d{1,2})?(?:,?\s+\d{4})?\)\s+/i;
                cleaned = cleaned.replace(datePrefix, '');

                // Remove trailing ellipsis (3 or more consecutive dots)
                cleaned = cleaned.replace(/\.{3,}$/, '');

                // Remove common publisher contamination from end
                // Pattern: ends with short capitalized segment like "Census.gov" or "American Public Media"
                // But be careful not to remove actual title words
                const publisherPattern = /\.\s*([A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,3}|[A-Z]{2,}(?:\.[a-z]+)?)\s*$/;
                const publisherMatch = cleaned.match(publisherPattern);
                if (publisherMatch) {
                    const potentialPublisher = publisherMatch[1];
                    // Only remove if it looks like a publisher (short, no lowercase start, common patterns)
                    if (potentialPublisher.length < 50 &&
                        (potentialPublisher.includes('.') || // like "Census.gov"
                         /^[A-Z][a-z]+(?:\s+[A-Z][a-z]+)+$/.test(potentialPublisher) || // like "American Public Media"
                         /^[A-Z]{2,}$/.test(potentialPublisher))) { // like "UNESCO"
                        cleaned = cleaned.substring(0, cleaned.length - publisherMatch[0].length).trim();
                    }
                }

                return cleaned.trim();
            },

            parseSimplifiedBiblio(ref, biblioSection) {
                // Simplified parsing: RID, Authors, Year, Title only
                // Everything else goes into "Other" field

                // Extract Year: (YYYY)
                const yearMatch = biblioSection.match(/\((\d{4})\)/);
                ref.year = yearMatch ? yearMatch[1] : '';

                if (yearMatch) {
                    // Authors: Everything before (Year)
                    const beforeYear = biblioSection.substring(0, biblioSection.indexOf(yearMatch[0])).trim();
                    ref.authors = beforeYear.replace(/[,;]\s*$/, '').trim();

                    // Title: First sentence after (Year). up to next period
                    // BUT: Skip periods inside edition markers like (2nd ed.), (Rev. ed.), etc.
                    const afterYear = biblioSection.substring(biblioSection.indexOf(yearMatch[0]) + yearMatch[0].length);
                    const afterYearCleaned = afterYear.replace(/^[\.\s,;]+/, ''); // Remove leading punctuation

                    // Find the real title boundary - skip periods inside parentheses with edition keywords
                    let titleEnd = -1;
                    let parenDepth = 0;
                    let inEditionParen = false;

                    for (let i = 0; i < afterYearCleaned.length; i++) {
                        const char = afterYearCleaned[i];

                        if (char === '(') {
                            parenDepth++;
                            // Check if this paren contains edition keywords
                            const lookAhead = afterYearCleaned.substring(i, Math.min(i + 20, afterYearCleaned.length));
                            if (/\((\d+(st|nd|rd|th))?\s*(ed\.|edition|rev\.|revised)/i.test(lookAhead)) {
                                inEditionParen = true;
                            }
                        } else if (char === ')') {
                            parenDepth--;
                            if (parenDepth === 0) {
                                inEditionParen = false;
                            }
                        } else if (char === '.' && parenDepth === 0 && !inEditionParen) {
                            // Found a period outside parentheses - this is likely the title boundary
                            titleEnd = i;
                            break;
                        }
                    }

                    if (titleEnd > 0) {
                        let title = afterYearCleaned.substring(0, titleEnd).trim();
                        let other = afterYearCleaned.substring(titleEnd + 1).trim();

                        // Enhanced edition detection - catches both parenthesized and plain text editions
                        // Examples: "(2nd ed)", "2nd Edition", "Updated Edition", "Revised"
                        const editionPatterns = [
                            /\s*\((\d+(st|nd|rd|th))?\s*(ed\.?|edition|rev\.?|revised)\)/gi,  // (2nd ed.) or (Revised)
                            /\s*,?\s*(\d+(st|nd|rd|th))\s+(ed\.?|edition)/gi,                  // 2nd ed or 2nd Edition
                            /\s*,?\s*(updated|revised|new)\s+(ed\.?|edition)/gi,               // Updated Edition, Revised Edition
                            /\s*,?\s*\(?(rev\.?|revised|updated)\)?/gi                         // (Rev.) or Revised
                        ];

                        // Try to find edition marker in title
                        let editionFound = false;
                        for (const pattern of editionPatterns) {
                            const match = title.match(pattern);
                            if (match && match.index !== undefined) {
                                // Found edition marker - everything from this point goes to "other"
                                const editionStart = match.index;
                                const editionAndAfter = title.substring(editionStart).trim();

                                // Move edition and everything after to "other" field
                                if (editionAndAfter) {
                                    other = editionAndAfter + (other ? ' ' + other : '');
                                }

                                // Clean title up to edition marker
                                title = title.substring(0, editionStart).trim();
                                editionFound = true;
                                break;
                            }
                        }

                        ref.title = this.cleanTitle(title);
                        ref.other = other.replace(/^[,.\s]+/, '').replace(/[.\s]+$/, '').trim(); // Clean leading/trailing punctuation
                    } else {
                        // No period found - entire text after year is title
                        let title = afterYearCleaned.trim();
                        let other = '';

                        // Enhanced edition detection (same patterns as above)
                        const editionPatterns = [
                            /\s*\((\d+(st|nd|rd|th))?\s*(ed\.?|edition|rev\.?|revised)\)/gi,
                            /\s*,?\s*(\d+(st|nd|rd|th))\s+(ed\.?|edition)/gi,
                            /\s*,?\s*(updated|revised|new)\s+(ed\.?|edition)/gi,
                            /\s*,?\s*\(?(rev\.?|revised|updated)\)?/gi
                        ];

                        for (const pattern of editionPatterns) {
                            const match = title.match(pattern);
                            if (match && match.index !== undefined) {
                                const editionStart = match.index;
                                other = title.substring(editionStart).trim();
                                title = title.substring(0, editionStart).trim();
                                break;
                            }
                        }

                        ref.title = this.cleanTitle(title);
                        ref.other = other.replace(/^[,.\s]+/, '').replace(/[.\s]+$/, '').trim();
                    }
                } else {
                    // No year found - treat first segment as author, rest as other
                    const firstPeriod = biblioSection.indexOf('.');
                    if (firstPeriod > 0) {
                        ref.authors = biblioSection.substring(0, firstPeriod).trim();
                        ref.other = biblioSection.substring(firstPeriod + 1).trim();
                    } else {
                        // Just one segment - must be author (like "Amnesty International")
                        ref.authors = biblioSection.trim();
                        ref.other = '';
                    }
                    ref.title = '';
                }

                // Clear all the individual fields - we're not using them anymore
                ref.container_title = '';
                ref.publisher = '';
                ref.volume = '';
                ref.issue = '';
                ref.pages = '';
                ref.edition = '';
                ref.doi = '';
                ref.isbn = '';
                ref.publisher_place = '';
            },

            exportFile() {
                // Export all references to decisions.txt format
                let content = '';
                const filename = 'decisions.txt';

                for (const ref of this.references) {
                    content += this.generateDecisionsEntry(ref, ref.finalized) + '\n';
                }

                const blob = new Blob([content], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);

                this.showToast('decisions.txt saved', 'success');

                // Also save to localStorage as backup
                localStorage.setItem('rr_decisions_backup', content);
                localStorage.setItem('rr_decisions_timestamp', new Date().toISOString());
            },

            exportOverrideLog() {
                // Export override log in JSONL format
                if (!this.overrideLog || this.overrideLog.length === 0) {
                    this.showToast('No overrides logged yet', 'info');
                    return;
                }

                const content = this.overrideLog.map(entry => JSON.stringify(entry)).join('\n');
                const filename = `override_log_${new Date().toISOString().split('T')[0]}.jsonl`;

                const blob = new Blob([content], { type: 'application/x-jsonlines' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);

                this.showToast('Override log exported', 'success');
            },

            autoSave() {
                // Debounced auto-save to localStorage
                clearTimeout(this.autoSaveTimeout);
                this.autoSaveTimeout = setTimeout(() => {
                    // Save references to localStorage
                    const content = this.references.map(ref =>
                        this.generateDecisionsEntry(ref, ref.finalized)
                    ).join('\n');

                    localStorage.setItem('rr_decisions_backup', content);
                    localStorage.setItem('rr_decisions_timestamp', new Date().toISOString());

                    // Save override log
                    localStorage.setItem('rr_override_log', JSON.stringify(this.overrideLog));

                    console.log('Auto-saved to localStorage');

                    // Show auto-save indicator
                    this.showAutoSaveIndicator();
                }, 500);  // 500ms debounce
            },

            showAutoSaveIndicator() {
                const indicator = document.getElementById('autoSaveIndicator');
                indicator.style.opacity = '1';
                setTimeout(() => {
                    indicator.style.opacity = '0';
                }, 2000);
            },

            showOverrideModal(details, onComplete) {
                // Show modal with override details
                document.getElementById('overrideDetails').innerHTML = details;
                document.getElementById('overrideAnnotation').value = '';
                document.getElementById('overrideModal').classList.add('visible');

                // Store callback for when modal closes
                this.overrideModalCallback = onComplete;
            },

            closeOverrideModal(shouldLog) {
                const annotation = document.getElementById('overrideAnnotation').value.trim();
                document.getElementById('overrideModal').classList.remove('visible');

                // Call the stored callback with the result
                if (this.overrideModalCallback) {
                    this.overrideModalCallback(shouldLog ? annotation : null);
                    this.overrideModalCallback = null;
                }
            },

            logOverride(overrideData) {
                // Add override to log
                const entry = {
                    timestamp: new Date().toISOString(),
                    ...overrideData
                };

                this.overrideLog.push(entry);

                // Save to localStorage
                localStorage.setItem('rr_override_log', JSON.stringify(this.overrideLog));

                // Update stats to reflect new override count
                this.updateStats();

                // Log to console for debugging
                console.log('Override logged:', entry);
            },

            saveModelPreference() {
                const model = document.getElementById('aiModelSelect').value;
                localStorage.setItem('rr_ai_model', model);
                console.log('Saved AI model preference:', model);
            },

            getSelectedModel() {
                return document.getElementById('aiModelSelect').value;
            },

            // Cost Tracking Functions
            calculateGoogleCost() {
                // Google Custom Search: $5 per 1,000 queries (paid tier)
                return (this.sessionCosts.googleSearches * 0.005).toFixed(4);
            },

            calculateClaudeCost() {
                // Claude Sonnet 4 pricing (as of Jan 2025):
                // Input: $0.003 per 1K tokens
                // Output: $0.015 per 1K tokens
                const totalInputTokens = this.sessionCosts.claudeQueryGenTokensIn + this.sessionCosts.claudeRankTokensIn;
                const totalOutputTokens = this.sessionCosts.claudeQueryGenTokensOut + this.sessionCosts.claudeRankTokensOut;

                const inputCost = (totalInputTokens / 1000) * 0.003;
                const outputCost = (totalOutputTokens / 1000) * 0.015;

                return (inputCost + outputCost).toFixed(4);
            },

            calculateTotalSessionCost() {
                const googleCost = parseFloat(this.calculateGoogleCost());
                const claudeCost = parseFloat(this.calculateClaudeCost());
                return (googleCost + claudeCost).toFixed(4);
            },

            resetSessionCosts() {
                this.sessionCosts = {
                    googleSearches: 0,
                    claudeQueryGenCalls: 0,
                    claudeQueryGenTokensIn: 0,
                    claudeQueryGenTokensOut: 0,
                    claudeRankCalls: 0,
                    claudeRankTokensIn: 0,
                    claudeRankTokensOut: 0
                };
            },

            trackGoogleSearch(queryCount = 1) {
                this.sessionCosts.googleSearches += queryCount;
                this.updateCostDisplay();
            },

            trackClaudeQueryGen(inputTokens, outputTokens) {
                this.sessionCosts.claudeQueryGenCalls++;
                this.sessionCosts.claudeQueryGenTokensIn += inputTokens || 0;
                this.sessionCosts.claudeQueryGenTokensOut += outputTokens || 0;
                this.updateCostDisplay();
            },

            trackClaudeRank(inputTokens, outputTokens) {
                this.sessionCosts.claudeRankCalls++;
                this.sessionCosts.claudeRankTokensIn += inputTokens || 0;
                this.sessionCosts.claudeRankTokensOut += outputTokens || 0;
                this.updateCostDisplay();
            },

            updateCostDisplay() {
                // Update the cost display in Debug tab
                const googleSearchEl = document.getElementById('costGoogleSearches');
                const claudeQueryGenEl = document.getElementById('costClaudeQueryGen');
                const claudeRankEl = document.getElementById('costClaudeRank');
                const googleCostEl = document.getElementById('costGoogle');
                const claudeCostEl = document.getElementById('costClaude');
                const totalCostEl = document.getElementById('costTotal');

                if (googleSearchEl) googleSearchEl.textContent = this.sessionCosts.googleSearches;
                if (claudeQueryGenEl) claudeQueryGenEl.textContent = `${this.sessionCosts.claudeQueryGenCalls} calls`;
                if (claudeRankEl) claudeRankEl.textContent = `${this.sessionCosts.claudeRankCalls} calls`;
                if (googleCostEl) googleCostEl.innerHTML = `<strong>$${this.calculateGoogleCost()}</strong>`;
                if (claudeCostEl) claudeCostEl.innerHTML = `<strong>$${this.calculateClaudeCost()}</strong>`;
                if (totalCostEl) totalCostEl.innerHTML = `<strong>$${this.calculateTotalSessionCost()}</strong>`;
            },

            addCostSummaryPanel() {
                // v14.2: Generate comprehensive cost summary panel
                const googleCost = parseFloat(this.calculateGoogleCost());
                const claudeCost = parseFloat(this.calculateClaudeCost());
                const sessionTotal = parseFloat(this.calculateTotalSessionCost());

                // Count references processed (finalized in this session)
                const processedCount = this.references.filter(r => r.finalized).length;
                const avgPerRef = processedCount > 0 ? (sessionTotal / processedCount).toFixed(4) : 'N/A';

                // Token breakdown
                const totalInputTokens = this.sessionCosts.claudeQueryGenTokensIn + this.sessionCosts.claudeRankTokensIn;
                const totalOutputTokens = this.sessionCosts.claudeQueryGenTokensOut + this.sessionCosts.claudeRankTokensOut;

                // Projections
                let projectionInfo = '';
                if (processedCount > 0) {
                    const costPerRef = sessionTotal / processedCount;
                    const proj100 = (costPerRef * 100).toFixed(2);
                    const proj500 = (costPerRef * 500).toFixed(2);

                    projectionInfo = `\n<strong>Projections (based on session average):</strong>
Next 100 references: ~$${proj100}
Next 500 references: ~$${proj500}`;
                }

                const panelContent = `<strong>Session Cost Summary:</strong>

<strong>Google Searches:</strong> ${this.sessionCosts.googleSearches} searches = $${googleCost}
<strong>Claude API:</strong>
  Query Generation: ${this.sessionCosts.claudeQueryGenCalls} calls
  Ranking: ${this.sessionCosts.claudeRankCalls} calls
  Total Tokens: ${(totalInputTokens + totalOutputTokens).toLocaleString()} (${totalInputTokens.toLocaleString()} in + ${totalOutputTokens.toLocaleString()} out)
  Cost: $${claudeCost}

<strong>Session Total:</strong> $${sessionTotal}
<strong>References Processed:</strong> ${processedCount}
<strong>Average Per Reference:</strong> $${avgPerRef}${projectionInfo}`;

                this.addDebugPanel('üí∞ Session Cost Summary', panelContent, 'info');
            },

            // Filtering and Display
            applyFilters() {
                // Toggle-based filtering: Both filters work as show/hide toggles
                const showFinalized = document.getElementById('showFinalizedToggle')?.checked || false;
                const showManualReview = document.getElementById('showManualReviewToggle')?.checked !== false; // Default to true (checked)

                this.filteredReferences = this.references.filter(ref => {
                    // Filter by finalized status
                    if (!showFinalized && ref.finalized) return false;

                    // Filter by manual review flag (if unchecked, hide refs needing review)
                    if (!showManualReview && ref.needsManualReview) return false;

                    return true;
                });

                // Always sort by ID ascending
                this.filteredReferences.sort((a, b) => {
                    const aId = parseInt(a.id) || 0;
                    const bId = parseInt(b.id) || 0;
                    return aId - bId;
                });

                // Display
                this.renderReferences();
                this.updateStats();
            },


            renderReferences() {
                const grid = document.getElementById('referencesGrid');
                grid.innerHTML = '';

                for (const ref of this.filteredReferences) {
                    const card = this.createReferenceCard(ref);
                    grid.appendChild(card);
                }
            },

            createReferenceCard(ref) {
                const card = document.createElement('div');
                card.className = 'reference-card' + (ref.finalized ? ' finalized' : '');

                // Check if this reference has any overrides
                const overrideCount = this.overrideLog.filter(o => o.rid === ref.id).length;

                // Build compact meta info (inline with bullets)
                let metaHtml = '';
                const metaParts = [];
                if (ref.container_title) metaParts.push(`${ref.container_title}`);
                if (ref.publisher) metaParts.push(ref.publisher);
                if (ref.volume) metaParts.push(`Vol. ${ref.volume}${ref.issue ? '(' + ref.issue + ')' : ''}`);
                if (ref.pages) metaParts.push(`pp. ${ref.pages}`);
                if (ref.isbn) metaParts.push(`ISBN: ${ref.isbn}`);
                if (metaParts.length > 0) {
                    metaHtml = `<div class="reference-meta">${metaParts.join(' ‚Ä¢ ')}</div>`;
                }

                card.innerHTML = `
                    <div class="reference-header">
                        <span class="reference-id">#${ref.id}</span>
                        ${ref.finalized ? '<span class="finalized-badge">Finalized</span>' : ''}
                        ${ref.needsManualReview ? '<span class="override-badge" style="background: var(--warning-color);" title="Low AI scores - manual review recommended">‚ö†Ô∏è Review</span>' : ''}
                        ${overrideCount > 0 ? `<span class="override-badge" title="${overrideCount} AI override${overrideCount > 1 ? 's' : ''}">üîÑ ${overrideCount}</span>` : ''}
                        ${ref.batchVersion ? `<span class="override-badge" style="background: #9b59b6;" title="Processed by batch ${ref.batchVersion}">ü§ñ ${ref.batchVersion}</span>` : ''}
                    </div>
                    <div class="reference-content">
                        <h3>${ref.title || 'Untitled'}</h3>
                        <div class="reference-authors">${ref.authors || 'Unknown authors'}</div>
                        ${ref.year ? `<span class="reference-year">${ref.year}</span>` : ''}
                        ${metaHtml}
                        ${ref.relevance_text ? `<div class="reference-relevance">${ref.relevance_text}</div>` : ''}
                    </div>
                    ${this.createUrlsSection(ref)}
                    <div class="reference-actions">
                        <button onclick="app.editReference('${ref.id}')">Edit</button>
                        ${!ref.finalized && ref.urls.primary ? `<button onclick="app.finalizeReference('${ref.id}')" style="background: var(--warning-color);">Finalize</button>` : ''}
                        ${!ref.finalized ? `<button onclick="app.toggleManualReview('${ref.id}')" style="background: ${ref.needsManualReview ? '#95a5a6' : 'var(--warning-color)'};" title="${ref.needsManualReview ? 'Clear Manual Review flag' : 'Mark for Manual Review'}">${ref.needsManualReview ? '‚úì Manual Review' : 'Manual Review'}</button>` : ''}
                        <button onclick="app.selectReference('${ref.id}'); app.showQuickNote();" style="background: #9b59b6;">üìù Note</button>
                    </div>
                `;
                return card;
            },

            createUrlsSection(ref) {
                const urls = [];
                if (ref.urls.primary) urls.push({ type: 'primary', label: 'Primary', url: ref.urls.primary });
                if (ref.urls.secondary) urls.push({ type: 'secondary', label: 'Secondary', url: ref.urls.secondary });

                if (urls.length === 0) return '';

                const urlsHtml = urls.map(u => `
                    <div class="url-item">
                        <span class="url-type ${u.type}">${u.label}</span>
                        <a href="${u.url}" target="_blank" class="url-link">${u.url}</a>
                    </div>
                `).join('');

                return `<div class="urls-section">${urlsHtml}</div>`;
            },

            updateStats() {
                document.getElementById('statTotal').textContent = this.references.length;
                document.getElementById('statFiltered').textContent = this.filteredReferences.length;

                const withUrls = this.references.filter(r => r.urls.primary || r.urls.secondary).length;
                const finalized = this.references.filter(r => r.finalized).length;

                document.getElementById('statUrls').textContent = withUrls;
                document.getElementById('statFinalized').textContent = finalized;
                document.getElementById('statOverrides').textContent = this.overrideLog.length;
            },

            // Tab Management
            switchTab(tabIndex) {
                this.currentTab = tabIndex;

                // Update tab buttons
                const tabs = document.querySelectorAll('.modal-tab');
                tabs.forEach((tab, index) => {
                    if (index === tabIndex) {
                        tab.classList.add('active');
                    } else {
                        tab.classList.remove('active');
                    }
                });

                // Update tab content
                const contents = document.querySelectorAll('.tab-content');
                contents.forEach((content, index) => {
                    if (index === tabIndex) {
                        content.classList.add('active');
                    } else {
                        content.classList.remove('active');
                    }
                });
            },

            // Edit Modal
            editReference(id) {
                const ref = this.references.find(r => r.id === id);
                if (!ref) return;

                this.currentEditId = id;
                this.debugPanels = [];
                this.sortFocus = 'primary';  // Reset sort focus to primary

                // Update modal title with RID and reference title
                const modalTitle = document.getElementById('modalTitle');
                const titleText = ref.title ? `: ${ref.title}` : '';
                modalTitle.textContent = `Edit Reference [${ref.id}]${titleText}`;

                // Hide sort toggle initially (will show when candidates are loaded)
                document.getElementById('sortToggleContainer').style.display = 'none';

                // Populate form - Tab 1 (simplified)
                document.getElementById('editId').value = ref.id;
                document.getElementById('editTitle').value = ref.title || '';
                document.getElementById('editAuthors').value = ref.authors || '';
                document.getElementById('editYear').value = ref.year || '';
                document.getElementById('editOther').value = ref.other || '';
                document.getElementById('editPrimaryUrl').value = ref.urls.primary || '';
                document.getElementById('editSecondaryUrl').value = ref.urls.secondary || '';
                document.getElementById('editRelevanceText').value = ref.relevance_text || '';
                document.getElementById('editQueries').value = ref.queries.join('\n');

                // Update modal header with reference info
                const modalReferenceInfo = document.getElementById('modalReferenceInfo');
                let refInfo = '';
                if (ref.authors) refInfo += `<strong>${ref.authors}</strong>`;
                if (ref.year) refInfo += ` (${ref.year})`;
                if (ref.title) {
                    if (refInfo) refInfo += ' ‚Äî ';
                    refInfo += `<em>${ref.title}</em>`;
                }
                modalReferenceInfo.innerHTML = refInfo || '<span style="font-style: italic;">No title/author info</span>';

                // Tab 2 - Clear candidates and populate URL displays
                document.getElementById('candidatesContainer').innerHTML = `
                    <p style="color: var(--text-secondary); text-align: center; padding: 2rem;">
                        No search results yet. Run queries in the "Suggest & Query" tab first.
                    </p>
                `;

                // Update Current URLs display
                const primaryUrlSpan = document.getElementById('displayPrimaryUrl');
                const secondaryUrlSpan = document.getElementById('displaySecondaryUrl');

                if (ref.urls.primary) {
                    primaryUrlSpan.innerHTML = `<a href="${ref.urls.primary}" target="_blank" style="color: var(--success-color); text-decoration: none;">${ref.urls.primary}</a>`;
                } else {
                    primaryUrlSpan.innerHTML = '<span style="color: var(--text-secondary); font-style: italic;">Not set</span>';
                }

                if (ref.urls.secondary) {
                    secondaryUrlSpan.innerHTML = `<a href="${ref.urls.secondary}" target="_blank" style="color: var(--accent-color); text-decoration: none;">${ref.urls.secondary}</a>`;
                } else {
                    secondaryUrlSpan.innerHTML = '<span style="color: var(--text-secondary); font-style: italic;">Not set</span>';
                }

                // Tab 3 - Initialize Debug Panels
                this.initializeDebugPanels(ref);

                // Switch to first tab and show modal
                this.switchTab(0);
                document.getElementById('editModal').classList.add('visible');
            },

            doneEditing() {
                // Log debug panels to session log (if needed)
                // The panels are already being logged as they're created
                // Just close the modal
                this.closeModal();
            },

            closeModal() {
                document.getElementById('editModal').classList.remove('visible');
                this.currentEditId = null;
                this.currentSystemLogPanel = null;  // Reset for next edit session
            },

            saveReference() {
                const ref = this.references.find(r => r.id === this.currentEditId);
                if (!ref) return;

                // Update reference from Tab 1 fields (simplified - no parsing)
                ref.title = document.getElementById('editTitle').value;
                ref.authors = document.getElementById('editAuthors').value;
                ref.year = document.getElementById('editYear').value;
                ref.other = document.getElementById('editOther').value;
                ref.urls.primary = document.getElementById('editPrimaryUrl').value;
                ref.urls.secondary = document.getElementById('editSecondaryUrl').value;
                ref.relevance_text = document.getElementById('editRelevanceText').value;
                ref.queries = document.getElementById('editQueries').value.split('\n').filter(q => q.trim());

                // Rebuild text for display
                let text = `[${ref.id}] ${ref.authors}`;
                if (ref.year) text += ` (${ref.year})`;
                if (ref.title) text += `. ${ref.title}`;
                if (ref.other) text += `. ${ref.other}`;
                ref.text = text;

                this.showToast('Reference saved', 'success');

                // Auto-save after changes
                this.autoSave();

                // Auto-save to Dropbox if connected
                this.saveDecisionsToDropbox();

                // Update display but keep modal open
                this.applyFilters();
            },

            finalizeReference(refId = null) {
                // If refId provided, finalize from main window (quick finalize)
                // Otherwise, finalize from Edit modal with form updates
                const targetRefId = refId || this.currentEditId;
                const ref = this.references.find(r => r.id === targetRefId);
                if (!ref) return;

                // If called from Edit modal, update reference from form fields
                if (!refId && this.currentEditId) {
                    // Validate: must have at least a primary URL
                    const primaryUrl = document.getElementById('editPrimaryUrl').value;
                    if (!primaryUrl) {
                        this.showToast('Cannot finalize: Must have at least a Primary URL', 'error');
                        return;
                    }

                    // Update reference from Tab 1 fields (same as saveReference)
                    ref.title = document.getElementById('editTitle').value;
                    ref.authors = document.getElementById('editAuthors').value;
                    ref.year = document.getElementById('editYear').value;
                    ref.other = document.getElementById('editOther').value;
                    ref.urls.primary = primaryUrl;
                    ref.urls.secondary = document.getElementById('editSecondaryUrl').value;
                    ref.relevance_text = document.getElementById('editRelevanceText').value;
                    ref.queries = document.getElementById('editQueries').value.split('\n').filter(q => q.trim());

                    // Rebuild text for display
                    let text = `[${ref.id}] ${ref.authors}`;
                    if (ref.year) text += ` (${ref.year})`;
                    if (ref.title) text += `. ${ref.title}`;
                    if (ref.other) text += `. ${ref.other}`;
                    ref.text = text;
                }
                // If called from main window, validate URLs exist
                else if (refId) {
                    if (!ref.urls.primary) {
                        this.showToast('Cannot finalize: Must have at least a Primary URL', 'error');
                        return;
                    }
                }

                // Mark as finalized
                ref.finalized = true;

                // Remove MANUAL_REVIEW flag when finalizing (v14.7)
                // Finalization resolves the "needs review" status
                if (ref.needsManualReview) {
                    ref.needsManualReview = false;
                }

                // Generate updated decisions.txt entry with FLAGS[FINALIZED]
                const decisionsEntry = this.generateDecisionsEntry(ref, true);

                // Show entry in debug log
                this.addDebugLog('=== FINALIZED REFERENCE ===');
                this.addDebugLog('\nDecisions.txt entry:\n' + decisionsEntry);

                this.showToast('Reference finalized! FLAGS[FINALIZED] added.', 'success');

                // Auto-save decisions.txt
                this.autoSave();

                // Auto-save to Dropbox if connected
                this.saveDecisionsToDropbox();

                // Update display but keep modal open (reference will disappear from view if "Show Finalized" is unchecked)
                this.applyFilters();
            },

            toggleManualReview(refId) {
                // v16.3: Toggle the MANUAL_REVIEW flag on a reference
                const ref = this.references.find(r => r.id === refId);
                if (!ref) return;

                // Can't toggle manual review on finalized references
                if (ref.finalized) {
                    this.showToast('Cannot change manual review flag on finalized reference', 'error');
                    return;
                }

                // Toggle the flag
                ref.needsManualReview = !ref.needsManualReview;

                const action = ref.needsManualReview ? 'marked for' : 'cleared from';
                this.showToast(`Reference ${action} manual review`, 'success');

                // Auto-save decisions.txt
                this.autoSave();

                // Auto-save to Dropbox if connected
                this.saveDecisionsToDropbox();

                // Update display
                this.applyFilters();
            },

            generateDecisionsEntry(ref, includeFinalized = false) {
                // v15.0: Single-line format with escaped special characters
                // Format: [RID] Author (Year). Title. Other. Relevance: text FLAGS[...] PRIMARY_URL[...] SECONDARY_URL[...]

                let entry = `[${ref.id}] `;

                // Add author if present
                if (ref.authors) {
                    entry += `${ref.authors} `;
                }

                // Add year if present
                if (ref.year) {
                    entry += `(${ref.year}). `;
                }

                // Add title if present
                if (ref.title) {
                    entry += `${ref.title}. `;
                }

                // Add other bibliographic information if present
                if (ref.other) {
                    entry += `${ref.other}. `;
                }

                // Add relevance text if present
                if (ref.relevance_text) {
                    entry += `Relevance: ${ref.relevance_text} `;
                }

                // Build FLAGS array
                const flags = [];
                if (includeFinalized || ref.finalized) {
                    flags.push('FINALIZED');
                }
                if (ref.needsManualReview && !ref.finalized) {
                    flags.push('MANUAL_REVIEW');
                }
                // v16.0: Add batch version if present
                if (ref.batchVersion) {
                    flags.push(`BATCH_${ref.batchVersion}`);
                }

                // Add FLAGS if any exist
                // v16.0: Join with spaces (not commas) to match batch-utils.js format
                if (flags.length > 0) {
                    entry += `FLAGS[${flags.join(' ')}] `;
                }

                // Add URLs (plain, not escaped - for compatibility with batch processor)
                if (ref.urls.primary) {
                    entry += `PRIMARY_URL[${ref.urls.primary}] `;
                }
                if (ref.urls.secondary) {
                    entry += `SECONDARY_URL[${ref.urls.secondary}] `;
                }
                if (ref.urls.tertiary) {
                    entry += `TERTIARY_URL[${ref.urls.tertiary}] `;
                }

                return entry.trim();
            },

            // v14.3: Simple Queries Toggle
            toggleSimpleQueries() {
                const toggle = document.getElementById('simpleQueriesToggle');
                const info = document.getElementById('simpleQueriesInfo');
                this.simpleQueries = toggle.checked;

                if (info) {
                    info.style.display = this.simpleQueries ? 'block' : 'none';
                }

                this.addDebugLog(this.simpleQueries ? 'Simple Queries mode enabled (3 queries)' : 'Standard mode (8 queries)');
            },

            // AI Operations
            async generateQueries() {
                const ref = this.references.find(r => r.id === this.currentEditId);
                if (!ref) return;

                const btn = event.target;
                const originalText = document.getElementById('suggestBtnText').textContent;
                btn.disabled = true;
                document.getElementById('suggestBtnText').innerHTML = '<span class="loading"></span> Generating...';

                this.addDebugLog('Generating search queries...');

                try {
                    let prompt;
                    let totalQueries;

                    // v14.3: Check if simple mode is enabled
                    if (this.simpleQueries) {
                        totalQueries = 3;
                        // Detect work type for review query
                        const otherInfo = (ref.other || '').toLowerCase();
                        let workType = 'book';
                        if (otherInfo.includes('journal') || otherInfo.includes('article')) {
                            workType = 'article';
                        } else if (otherInfo.includes('film') || otherInfo.includes('documentary')) {
                            workType = 'film';
                        }

                        prompt = `You are helping find URLs for an academic reference. Generate EXACTLY 3 search queries using this simple structure:

REFERENCE:
Title: ${ref.title || 'Unknown'}
Authors: ${ref.authors || 'Unknown'}
Year: ${ref.year || 'Unknown'}
Other Info: ${ref.other || 'None'}

RELEVANCE (context for topic keywords):
${ref.relevance_text || 'No context provided'}

QUERY STRUCTURE (generate EXACTLY 3 queries):

Query 1 - BROAD TITLE+AUTHOR SEARCH:
Format: "{exact title}" {author last name}
Goal: Cast wide net for the work in any format
Example: "Making the Social World" Searle

Query 2 - REVIEW SEARCH:
Format: "{exact title}" ${workType} review
Goal: Find scholarly reviews or analyses of THIS SPECIFIC WORK
Example: "Making the Social World" book review

Query 3 - TOPIC KEYWORDS:
Format: {5-8 key concepts/topics from title and relevance, NO quotes}
Goal: Broader conceptual search for related discussions
Example: social ontology collective intentionality institutional facts Searle

IMPORTANT:
- Query 1: Use full exact title in quotes + author last name only
- Query 2: Use full exact title in quotes + "${workType} review"
- Query 3: Extract 5-8 core concepts/keywords, no quotes, space-separated
- Return ONLY 3 queries, one per line
- No labels, numbering, or explanations`;

                    } else {
                        // Standard 8-query mode (keep existing logic for backward compatibility)
                        totalQueries = 8;
                        const primaryQueries = 4;
                        const secondaryQueries = 4;

                        prompt = `You are helping find URLs for an academic reference. Generate 8 search queries using the structured approach below.

REFERENCE:
Title: ${ref.title || 'Unknown'}
Authors: ${ref.authors || 'Unknown'}
Year: ${ref.year || 'Unknown'}
Other Info: ${ref.other || 'None'}

RELEVANCE (why this matters):
${ref.relevance_text || 'No context provided'}

STRUCTURE (follow exactly - 8 queries total, 4 primary + 4 secondary):

PRIMARY-FOCUSED QUERIES (4 queries):
Q1-Q3 (3 queries): FULL-TEXT SOURCES (free preferred)
  - Exact title + author + year + filetype:pdf
  - Title/author + site:.edu OR site:.gov (academic repositories)
  - Title/author + site:archive.org OR site:researchgate.net OR site:academia.edu (free archives)
  Goal: Find FREE full-text PDFs or HTML versions. Prioritize open access.

Q4 (1 query): PUBLISHER/PURCHASE PAGE
  - Publisher name + title + author + year
  Goal: Official source where the work can be purchased or previewed.

SECONDARY-FOCUSED QUERIES (4 queries):
Q5-Q7 (3 queries): REVIEWS/ANALYSES OF THIS SPECIFIC WORK
  - Title + "review" + academic journal or scholarly
  - Title + author + "analysis" OR "critique" OR "discussion"
  - Title + author + "summary" OR "overview" + academic context
  Goal: Find scholarly reviews, critiques, or analyses of THIS SPECIFIC WORK (not just the topic).

Q8 (1 query): SCHOLARLY TOPIC ANALYSIS (fallback)
  - Use proper phrases, NOT keyword strings: "scholarly analysis of [key concepts]" OR "empirical research on [key concepts]" OR "theoretical frameworks for [key concepts]"
  - Add qualifiers like "peer-reviewed", "academic discussion", "research perspectives"
  Goal: Find academic discussions using complete phrases, not just keyword lists.

QUERY BEST PRACTICES:
‚úì Use exact title in quotes for primary and review queries
‚úì Keep queries 40-80 characters (max 120)
‚úì Use 1-2 quoted phrases per query max
‚úì Prioritize free sources over paywalled

AVOID:
‚ùå URLs or domain names in queries (except site: operator)
‚ùå Overly specific jargon combinations
‚ùå ISBN + publisher + full title together (too specific)

Return ONLY 8 queries, one per line, in order. No labels, categories, or explanations.`;
                    }

                    const model = this.getSelectedModel();
                    const response = await this.apiRequest('/api/llm-chat', {
                        method: 'POST',
                        body: JSON.stringify({ prompt, model })
                    });

                    if (response.result) {
                        document.getElementById('editQueries').value = response.result;
                        // Store AI-suggested query for override detection
                        this.aiSuggestedQuery = response.result;

                        // Track cost
                        let costInfo = '';
                        if (response.input_tokens && response.output_tokens) {
                            this.trackClaudeQueryGen(response.input_tokens, response.output_tokens);
                            const cost = ((response.input_tokens / 1000) * 0.003) + ((response.output_tokens / 1000) * 0.015);
                            costInfo = `\n<strong>Tokens:</strong> ${response.input_tokens.toLocaleString()} input + ${response.output_tokens.toLocaleString()} output
<strong>Cost:</strong> $${cost.toFixed(4)}`;
                        }

                        // Add debug panel with cost info
                        const panelContent = `<strong>AI Model:</strong> ${model}
<strong>Queries Generated:</strong>
${response.result}${costInfo}`;
                        this.addDebugPanel('Query Generation (AI)', panelContent, 'success');

                        // Add cumulative cost panel
                        this.addCostSummaryPanel();

                        this.showToast('Queries generated', 'success');
                    }
                } catch (error) {
                    const errorMsg = error.message || error.toString();
                    this.addDebugLog('Error generating queries: ' + errorMsg);
                    this.showToast('Query generation failed. Check Debug tab (Tab 3) for details.', 'error');
                    console.error('Generate queries error:', error);
                } finally {
                    btn.disabled = false;
                    document.getElementById('suggestBtnText').textContent = originalText;
                }
            },

            async runSearch() {
                const currentQuery = document.getElementById('editQueries').value;

                // Check if user modified AI-suggested query
                if (this.aiSuggestedQuery && currentQuery !== this.aiSuggestedQuery) {
                    const ref = this.references.find(r => r.id === this.currentEditId);
                    const details = `
                        <p><strong>AI Suggested Query:</strong></p>
                        <pre style="background: var(--background); padding: 0.5rem; border-radius: 4px; white-space: pre-wrap; font-size: 0.9rem; max-height: 150px; overflow-y: auto;">${this.aiSuggestedQuery}</pre>
                        <p style="margin-top: 1rem;"><strong>Your Modified Query:</strong></p>
                        <pre style="background: var(--background); padding: 0.5rem; border-radius: 4px; white-space: pre-wrap; font-size: 0.9rem; max-height: 150px; overflow-y: auto;">${currentQuery}</pre>
                    `;

                    await new Promise((resolve) => {
                        this.showOverrideModal(details, (annotation) => {
                            if (annotation !== null) {
                                this.logOverride({
                                    rid: this.currentEditId,
                                    override_type: 'QUERY',
                                    reference_title: ref?.title || 'Unknown',
                                    ai_suggested_query: this.aiSuggestedQuery,
                                    user_final_query: currentQuery,
                                    user_annotation: annotation
                                });
                            }
                            resolve();
                        });
                    });
                }

                const queries = currentQuery.split('\n').filter(q => q.trim());
                if (queries.length === 0) {
                    this.showToast('Enter search queries first', 'warning');
                    return;
                }

                const btn = event.target;
                const originalText = document.getElementById('queryBtnText').textContent;
                btn.disabled = true;
                document.getElementById('queryBtnText').innerHTML = '<span class="loading"></span> Searching...';

                this.addDebugLog('Running searches for ' + queries.length + ' queries...');

                try {
                    const results = [];

                    for (const query of queries) {
                        this.addDebugLog('Searching: ' + query);
                        const response = await this.apiRequest('/api/search-google', {
                            method: 'POST',
                            body: JSON.stringify({ query })
                        });

                        if (response.results) {
                            results.push(...response.results);
                            this.addDebugLog(`Found ${response.results.length} results`);
                        }
                    }

                    // Deduplicate by URL
                    const unique = Array.from(new Map(results.map(r => [r.url, r])).values());
                    this.addDebugLog(`Total unique results: ${unique.length}`);

                    // Track Google search cost
                    this.trackGoogleSearch(queries.length);

                    // Display results in Tab 2
                    this.displaySearchResults(unique);

                    // Store results
                    const ref = this.references.find(r => r.id === this.currentEditId);
                    if (ref) ref.searchResults = unique;

                    // Auto-switch to Tab 2
                    this.switchTab(1);

                    this.showToast(`Found ${unique.length} results`, 'success');
                } catch (error) {
                    const errorMsg = error.message || error.toString();
                    this.addDebugLog('Search error: ' + errorMsg);
                    this.showToast('Search failed. Check Debug tab (Tab 3) for details.', 'error');
                    console.error('Search error:', error);
                } finally {
                    btn.disabled = false;
                    document.getElementById('queryBtnText').textContent = originalText;
                }
            },

            displaySearchResults(results) {
                const container = document.getElementById('candidatesContainer');
                const ref = this.references.find(r => r.id === this.currentEditId);

                if (results.length === 0) {
                    container.innerHTML = `
                        <p style="color: var(--text-secondary); text-align: center; padding: 2rem;">
                            No results found. Try different queries.
                        </p>
                    `;
                    return;
                }

                container.innerHTML = results.map((r, i) => {
                    // Check if this URL is already assigned
                    let assignedType = '';
                    let badgeHtml = '';
                    if (ref) {
                        if (ref.urls.primary === r.url) {
                            assignedType = 'primary';
                            badgeHtml = '<span style="background: var(--success-color); color: white; padding: 0.2rem 0.5rem; border-radius: 4px; font-size: 0.75rem; font-weight: 600; margin-left: 0.5rem;">‚úì PRIMARY</span>';
                        } else if (ref.urls.secondary === r.url) {
                            assignedType = 'secondary';
                            badgeHtml = '<span style="background: var(--accent-color); color: white; padding: 0.2rem 0.5rem; border-radius: 4px; font-size: 0.75rem; font-weight: 600; margin-left: 0.5rem;">‚úì SECONDARY</span>';
                        }
                    }

                    const itemClass = assignedType ? `candidate-item selected-${assignedType}` : 'candidate-item';

                    return `
                        <div class="${itemClass}" data-index="${i}" data-url="${r.url}">
                            <div class="candidate-buttons">
                                <button onclick="app.selectCandidate(${i}, 'primary')" class="success">
                                    Set as Primary
                                </button>
                                <button onclick="app.selectCandidate(${i}, 'secondary')">
                                    Set as Secondary
                                </button>
                            </div>
                            <div class="candidate-content">
                                <div>
                                    <div class="candidate-header">
                                        <div class="candidate-title">${r.title}${badgeHtml}</div>
                                    </div>
                                    <div class="candidate-snippet">${r.snippet}</div>
                                </div>
                                <a href="${r.url}" target="_blank" class="candidate-url">${r.url}</a>
                            </div>
                        </div>
                    `;
                }).join('');

                // Show sort toggle if we have results
                if (results.length > 0) {
                    document.getElementById('sortToggleContainer').style.display = 'block';
                }
            },

            setSortFocus(focus) {
                this.sortFocus = focus;

                // Update button styles
                const primaryBtn = document.getElementById('sortByPrimary');
                const secondaryBtn = document.getElementById('sortBySecondary');

                if (focus === 'primary') {
                    primaryBtn.style.background = 'var(--accent-color)';
                    primaryBtn.style.color = 'white';
                    secondaryBtn.style.background = 'transparent';
                    secondaryBtn.style.color = 'var(--text-secondary)';
                } else {
                    secondaryBtn.style.background = 'var(--accent-color)';
                    secondaryBtn.style.color = 'white';
                    primaryBtn.style.background = 'transparent';
                    primaryBtn.style.color = 'var(--text-secondary)';
                }

                // Re-render candidates with new sort
                const ref = this.references.find(r => r.id === this.currentEditId);
                if (ref && ref.searchResults) {
                    this.renderCandidates(ref.searchResults, ref.rankings || null);
                }
            },

            renderCandidates(candidates, rankings = null) {
                const container = document.getElementById('candidatesContainer');
                const ref = this.references.find(r => r.id === this.currentEditId);

                if (!candidates || candidates.length === 0) {
                    container.innerHTML = `
                        <p style="color: var(--text-secondary); text-align: center; padding: 2rem;">
                            No results found. Try different queries.
                        </p>
                    `;
                    document.getElementById('sortToggleContainer').style.display = 'none';
                    return;
                }

                // Show sort toggle
                document.getElementById('sortToggleContainer').style.display = 'block';

                // If we have rankings, deduplicate and sort
                if (rankings && rankings.length > 0) {
                    // Create ranking map
                    const rankingMap = new Map();
                    rankings.forEach(ranking => {
                        rankingMap.set(ranking.index, ranking);
                    });

                    // Deduplicate by URL
                    const urlMap = new Map();
                    candidates.forEach((result, index) => {
                        const ranking = rankingMap.get(index) || { primary_score: 0, secondary_score: 0, combined_score: 0 };
                        if (!urlMap.has(result.url)) {
                            urlMap.set(result.url, { result, originalIndex: index, ranking });
                        } else {
                            const existing = urlMap.get(result.url);
                            if (ranking.combined_score > existing.ranking.combined_score) {
                                urlMap.set(result.url, { result, originalIndex: index, ranking });
                            }
                        }
                    });

                    // Sort based on current focus
                    let sortedResults = Array.from(urlMap.values()).sort((a, b) => {
                        if (this.sortFocus === 'primary') {
                            // Sort by primary score first
                            if (b.ranking.primary_score !== a.ranking.primary_score) {
                                return b.ranking.primary_score - a.ranking.primary_score;
                            }
                            return b.ranking.secondary_score - a.ranking.secondary_score;
                        } else {
                            // Sort by secondary score first
                            if (b.ranking.secondary_score !== a.ranking.secondary_score) {
                                return b.ranking.secondary_score - a.ranking.secondary_score;
                            }
                            return b.ranking.primary_score - a.ranking.primary_score;
                        }
                    });

                    // Move designated URL to top based on current focus
                    if (this.sortFocus === 'primary' && ref.urls.primary) {
                        const designatedItem = sortedResults.find(item => item.result.url === ref.urls.primary);
                        if (designatedItem) {
                            sortedResults = sortedResults.filter(item => item.result.url !== ref.urls.primary);
                            sortedResults.unshift(designatedItem);
                        }
                    } else if (this.sortFocus === 'secondary' && ref.urls.secondary) {
                        const designatedItem = sortedResults.find(item => item.result.url === ref.urls.secondary);
                        if (designatedItem) {
                            sortedResults = sortedResults.filter(item => item.result.url !== ref.urls.secondary);
                            sortedResults.unshift(designatedItem);
                        }
                    }

                    // Render ranked candidates
                    container.innerHTML = sortedResults.map((item) => {
                        const r = item.result;
                        const ranking = item.ranking;
                        const originalIndex = item.originalIndex;

                        let assignedType = '';
                        let badgeHtml = '';
                        if (ref.urls.primary === r.url) {
                            assignedType = 'primary';
                            badgeHtml = '<span style="background: var(--success-color); color: white; padding: 0.2rem 0.5rem; border-radius: 4px; font-size: 0.75rem; font-weight: 600; margin-left: 0.5rem;">‚úì PRIMARY</span>';
                        } else if (ref.urls.secondary === r.url) {
                            assignedType = 'secondary';
                            badgeHtml = '<span style="background: var(--accent-color); color: white; padding: 0.2rem 0.5rem; border-radius: 4px; font-size: 0.75rem; font-weight: 600; margin-left: 0.5rem;">‚úì SECONDARY</span>';
                        }

                        const itemClass = assignedType ? `candidate-item selected-${assignedType}` : 'candidate-item';

                        const dualPurpose = ranking.primary_score > 60 && ranking.secondary_score > 60;
                        const scoreHtml = ranking.primary_score ? `
                            <div class="candidate-score" title="${ranking.primary_fit || 'N/A'} | ${ranking.secondary_fit || 'N/A'}">
                                ${dualPurpose ? '‚ö° ' : ''}
                                P:${ranking.primary_score} S:${ranking.secondary_score}
                                (${ranking.combined_score})
                            </div>
                        ` : '';

                        return `
                            <div class="${itemClass}" data-index="${originalIndex}" data-url="${r.url}">
                                <div class="candidate-buttons">
                                    <button onclick="app.selectCandidate(${originalIndex}, 'primary')" class="success">
                                        Set as Primary
                                    </button>
                                    <button onclick="app.selectCandidate(${originalIndex}, 'secondary')">
                                        Set as Secondary
                                    </button>
                                </div>
                                <div class="candidate-content">
                                    <div>
                                        <div class="candidate-header">
                                            <div class="candidate-title">${r.title}${badgeHtml}</div>
                                            ${scoreHtml}
                                        </div>
                                        <div class="candidate-snippet">${r.snippet}</div>
                                    </div>
                                    <a href="${r.url}" target="_blank" class="candidate-url">${r.url}</a>
                                </div>
                            </div>
                        `;
                    }).join('');
                } else {
                    // No rankings, just display in original order
                    container.innerHTML = candidates.map((r, i) => {
                        let assignedType = '';
                        let badgeHtml = '';
                        if (ref) {
                            if (ref.urls.primary === r.url) {
                                assignedType = 'primary';
                                badgeHtml = '<span style="background: var(--success-color); color: white; padding: 0.2rem 0.5rem; border-radius: 4px; font-size: 0.75rem; font-weight: 600; margin-left: 0.5rem;">‚úì PRIMARY</span>';
                            } else if (ref.urls.secondary === r.url) {
                                assignedType = 'secondary';
                                badgeHtml = '<span style="background: var(--accent-color); color: white; padding: 0.2rem 0.5rem; border-radius: 4px; font-size: 0.75rem; font-weight: 600; margin-left: 0.5rem;">‚úì SECONDARY</span>';
                            }
                        }

                        const itemClass = assignedType ? `candidate-item selected-${assignedType}` : 'candidate-item';

                        return `
                            <div class="${itemClass}" data-index="${i}" data-url="${r.url}">
                                <div class="candidate-buttons">
                                    <button onclick="app.selectCandidate(${i}, 'primary')" class="success">
                                        Set as Primary
                                    </button>
                                    <button onclick="app.selectCandidate(${i}, 'secondary')">
                                        Set as Secondary
                                    </button>
                                </div>
                                <div class="candidate-content">
                                    <div>
                                        <div class="candidate-header">
                                            <div class="candidate-title">${r.title}${badgeHtml}</div>
                                        </div>
                                        <div class="candidate-snippet">${r.snippet}</div>
                                    </div>
                                    <a href="${r.url}" target="_blank" class="candidate-url">${r.url}</a>
                                </div>
                            </div>
                        `;
                    }).join('');
                }
            },

            async selectCandidate(index, urlType) {
                const ref = this.references.find(r => r.id === this.currentEditId);
                if (!ref || !ref.searchResults || !ref.searchResults[index]) return;

                const candidate = ref.searchResults[index];
                let overrideData = null; // Track override info for session log

                // Check if user is overriding AI ranking
                if (this.aiRankedResults && this.aiRankedResults.allRankings) {
                    const aiSuggestion = urlType === 'primary' ? this.aiRankedResults.primary : this.aiRankedResults.secondary;

                    if (aiSuggestion && candidate.url !== aiSuggestion) {
                        // Find AI ranking for suggested URL
                        const aiRanking = this.aiRankedResults.allRankings.find(r =>
                            ref.searchResults[r.index]?.url === aiSuggestion);

                        // Find AI ranking for user's selected URL
                        const userRanking = this.aiRankedResults.allRankings.find(r =>
                            ref.searchResults[r.index]?.url === candidate.url);

                        const details = `
                            <p><strong>AI Recommended ${urlType.toUpperCase()} URL:</strong></p>
                            <div style="background: var(--background); padding: 0.5rem; border-radius: 4px; margin: 0.5rem 0; font-size: 0.9rem;">
                                <a href="${aiSuggestion}" target="_blank" style="color: var(--accent-color);">${aiSuggestion}</a>
                                ${aiRanking ? `<br><small>P:${aiRanking.primary_score} S:${aiRanking.secondary_score}</small>` : ''}
                            </div>
                            <p style="margin-top: 1rem;"><strong>Your Selected ${urlType.toUpperCase()} URL:</strong></p>
                            <div style="background: var(--background); padding: 0.5rem; border-radius: 4px; margin: 0.5rem 0; font-size: 0.9rem;">
                                <a href="${candidate.url}" target="_blank" style="color: var(--accent-color);">${candidate.url}</a>
                                ${userRanking ? `<br><small>P:${userRanking.primary_score} S:${userRanking.secondary_score}</small>` : ''}
                            </div>
                        `;

                        await new Promise((resolve) => {
                            this.showOverrideModal(details, (annotation) => {
                                if (annotation !== null) {
                                    // Store override data for session log
                                    overrideData = {
                                        aiSuggestion,
                                        aiRanking,
                                        userRanking,
                                        annotation
                                    };

                                    // Enhanced logging with full context to override log
                                    this.logOverride({
                                        rid: this.currentEditId,
                                        override_type: 'RANKING_' + urlType.toUpperCase(),
                                        reference_metadata: {
                                            title: ref.title,
                                            authors: ref.authors,
                                            year: ref.year,
                                            has_doi: ref.other?.includes('DOI:') || false,
                                            has_isbn: ref.other?.includes('ISBN:') || false
                                        },
                                        ai_suggested: {
                                            url: aiSuggestion,
                                            primary_score: aiRanking?.primary_score || 0,
                                            secondary_score: aiRanking?.secondary_score || 0,
                                            primary_fit: aiRanking?.primary_fit || '',
                                            secondary_fit: aiRanking?.secondary_fit || ''
                                        },
                                        user_selected: {
                                            url: candidate.url,
                                            was_ranked: userRanking ? this.aiRankedResults.allRankings.indexOf(userRanking) + 1 : 'unranked',
                                            primary_score: userRanking?.primary_score || 0,
                                            secondary_score: userRanking?.secondary_score || 0
                                        },
                                        user_annotation: annotation
                                    });
                                }
                                resolve();
                            });
                        });
                    }
                }

                if (urlType === 'primary') {
                    ref.urls.primary = candidate.url;
                    document.getElementById('editPrimaryUrl').value = candidate.url;
                    // Update display in Candidates tab
                    document.getElementById('displayPrimaryUrl').innerHTML = `<a href="${candidate.url}" target="_blank" style="color: var(--success-color); text-decoration: none;">${candidate.url}</a>`;
                    this.showToast('Set as Primary URL', 'success');
                } else if (urlType === 'secondary') {
                    ref.urls.secondary = candidate.url;
                    document.getElementById('editSecondaryUrl').value = candidate.url;
                    // Update display in Candidates tab
                    document.getElementById('displaySecondaryUrl').innerHTML = `<a href="${candidate.url}" target="_blank" style="color: var(--accent-color); text-decoration: none;">${candidate.url}</a>`;
                    this.showToast('Set as Secondary URL', 'success');
                }

                // Auto-save after URL change
                this.autoSave();

                // Update visual selection
                document.querySelectorAll('.candidate-item').forEach(item => {
                    item.classList.remove('selected-primary', 'selected-secondary');
                });

                const item = document.querySelector(`[data-index="${index}"]`);
                if (item) {
                    item.classList.add(urlType === 'primary' ? 'selected-primary' : 'selected-secondary');
                }

                // Log selection to session log - enhanced with override info if present
                const queryInfo = candidate.query ? `Found by query: ${candidate.query}` : '';

                if (overrideData) {
                    // This was an override - log detailed information to session
                    const aiRank = overrideData.aiRanking;
                    const userRank = overrideData.userRanking;

                    const panelContent = `<strong>üîÑ AI Override - ${urlType.toUpperCase()} URL</strong>

<strong>AI Recommended:</strong>
URL: ${overrideData.aiSuggestion}
Primary Score: ${aiRank?.primary_score || 'N/A'}
Secondary Score: ${aiRank?.secondary_score || 'N/A'}
${aiRank?.primary_fit ? `Fit: ${aiRank.primary_fit}` : ''}

<strong>You Selected:</strong>
URL: ${candidate.url}
Primary Score: ${userRank?.primary_score || 'N/A'}
Secondary Score: ${userRank?.secondary_score || 'N/A'}
${userRank ? `Ranked Position: #${this.aiRankedResults.allRankings.indexOf(userRank) + 1}` : 'Not ranked by AI'}
${queryInfo ? `${queryInfo}` : ''}

<strong>Your Reason:</strong>
"${overrideData.annotation}"`;

                    this.addDebugPanel(`URL Override (${urlType})`, panelContent, 'warning');
                } else {
                    // Normal selection - simple log
                    this.addDebugLog(`Selected as ${urlType} URL: ${candidate.url}${queryInfo ? '\n' + queryInfo : ''}`);
                }
            },

            async rankCandidates() {
                const ref = this.references.find(r => r.id === this.currentEditId);
                if (!ref || !ref.searchResults || ref.searchResults.length === 0) {
                    this.showToast('No search results to rank', 'warning');
                    return;
                }

                const btn = event.target;
                const originalText = document.getElementById('rankBtnText').textContent;
                btn.disabled = true;
                document.getElementById('rankBtnText').innerHTML = '<span class="loading"></span> Ranking...';

                // Batch processing for large result sets
                // v13.6: Disabled search tool in llm-rank.ts (was the actual bottleneck)
                // v13.7: Increased batch size to 35 (still had timeout issues)
                // v13.8: Reduced to 15 + added 18s timeout + reduced max_tokens to 1500 (still timing out at 19s)
                // v13.9: Reduced to 10 + max_tokens 800 + simplified prompt
                // v13.12: Increased to 15 with improved prompt structure (clearer scoring criteria)
                const batchSize = 15;
                const totalCandidates = ref.searchResults.length;
                const numBatches = Math.ceil(totalCandidates / batchSize);

                this.addDebugLog(`Ranking ${totalCandidates} candidates in ${numBatches} batch(es)...`);

                if (numBatches > 1) {
                    this.showToast(`Ranking ${totalCandidates} candidates in ${numBatches} batches...`, 'info');
                } else if (totalCandidates > 20) {
                    this.showToast(`Ranking ${totalCandidates} candidates - this may take 12-18 seconds...`, 'info');
                }

                try {
                    const model = this.getSelectedModel();
                    let allRankings = [];
                    let allCandidates = ref.searchResults;

                    // Process each batch
                    for (let batchIndex = 0; batchIndex < numBatches; batchIndex++) {
                        const startIdx = batchIndex * batchSize;
                        const endIdx = Math.min(startIdx + batchSize, totalCandidates);
                        const batchCandidates = ref.searchResults.slice(startIdx, endIdx);

                        if (numBatches > 1) {
                            this.addDebugLog(`Processing batch ${batchIndex + 1}/${numBatches} (candidates ${startIdx + 1}-${endIdx})...`);
                            document.getElementById('rankBtnText').innerHTML = `<span class="loading"></span> Batch ${batchIndex + 1}/${numBatches}...`;
                        }

                        const response = await this.apiRequest('/api/llm-rank', {
                            method: 'POST',
                            body: JSON.stringify({
                                reference: {
                                    title: ref.title,
                                    authors: ref.authors,
                                    year: ref.year,
                                    other: ref.other,
                                    relevance_text: ref.relevance_text
                                },
                                candidates: batchCandidates,
                                model: model
                            })
                        });

                        if (!response.rankings || response.rankings.length === 0) {
                            if (response.error) {
                                throw new Error(response.error);
                            }
                            this.addDebugLog(`Warning: Batch ${batchIndex + 1} returned no rankings`);
                            continue;
                        }

                        // Track tokens for this batch
                        if (response.input_tokens && response.output_tokens) {
                            this.trackClaudeRank(response.input_tokens, response.output_tokens);
                        }

                        // Adjust indices to account for batch offset
                        const adjustedRankings = response.rankings.map(ranking => ({
                            ...ranking,
                            index: ranking.index + startIdx
                        }));

                        allRankings = allRankings.concat(adjustedRankings);

                        // If Claude performed additional searches in this batch
                        if (response.searches_performed && response.searches_performed > 0) {
                            this.addDebugLog(`Batch ${batchIndex + 1}: AI performed ${response.searches_performed} additional search(es)`);
                            if (response.allCandidates && response.allCandidates.length > batchCandidates.length) {
                                // New candidates were found - add them to the end
                                const newCandidates = response.allCandidates.slice(batchCandidates.length);
                                allCandidates = allCandidates.concat(newCandidates);
                                ref.searchResults = allCandidates;
                                this.addDebugLog(`Added ${newCandidates.length} new candidate(s) from AI searches`);
                            }
                        }
                    }

                    // Create a response object that matches the expected format
                    const response = {
                        rankings: allRankings,
                        allCandidates: allCandidates,
                        searches_performed: allRankings.filter(r => r._newCandidate).length
                    };

                    if (response.rankings && response.rankings.length > 0) {
                        // Check if Claude performed additional searches
                        if (response.searches_performed && response.searches_performed > 0) {
                            this.addDebugLog(`AI performed ${response.searches_performed} additional search(es) to find better candidates`);

                            // Update searchResults with expanded candidate list
                            if (response.allCandidates && response.allCandidates.length > ref.searchResults.length) {
                                const newCandidatesCount = response.allCandidates.length - ref.searchResults.length;
                                ref.searchResults = response.allCandidates;
                                this.addDebugLog(`Added ${newCandidatesCount} new candidate(s) from AI searches`);
                            }
                        }

                        this.addDebugLog(`Received ${response.rankings.length} rankings from AI`);

                        // Track Claude ranking cost
                        if (response.input_tokens && response.output_tokens) {
                            this.trackClaudeRank(response.input_tokens, response.output_tokens);
                        }

                        // Store full AI rankings for override detection
                        this.aiRankedResults = {
                            primary: null,
                            secondary: null,
                            allRankings: response.rankings
                        };

                        // Find best PRIMARY and SECONDARY recommendations
                        // v13.12: Changed to prioritize HIGHEST SCORE, use recommended_as only for tie-breaking
                        const bestPrimary = response.rankings.reduce((best, curr) => {
                            if (!best) return curr;
                            // If current has higher primary score, choose it
                            if (curr.primary_score > best.primary_score) return curr;
                            // If scores are tied, prefer the one marked as 'primary' by AI
                            if (curr.primary_score === best.primary_score && curr.recommended_as === 'primary') return curr;
                            return best;
                        }, null);

                        const bestSecondary = response.rankings.reduce((best, curr) => {
                            if (!best) return curr;
                            // Skip if this is the primary candidate
                            if (bestPrimary && curr.index === bestPrimary.index) return best;
                            // If current has higher secondary score, choose it
                            if (curr.secondary_score > best.secondary_score) return curr;
                            // If scores are tied, prefer the one marked as 'secondary' by AI
                            if (curr.secondary_score === best.secondary_score && curr.recommended_as === 'secondary') return curr;
                            return best;
                        }, null);

                        // Check for low scores and flag reference
                        let flagWarnings = [];

                        if (!bestPrimary || bestPrimary.primary_score < 75) {
                            flagWarnings.push(`‚ö†Ô∏è PRIMARY: ${bestPrimary ? `Low confidence (score: ${bestPrimary.primary_score})` : 'No suitable candidate found'}`);
                            if (bestPrimary?.primary_fit) {
                                flagWarnings.push(`   Reason: ${bestPrimary.primary_fit}`);
                            }
                        }

                        if (!bestSecondary || bestSecondary.secondary_score < 75) {
                            flagWarnings.push(`‚ö†Ô∏è SECONDARY: ${bestSecondary ? `Low confidence (score: ${bestSecondary.secondary_score})` : 'No suitable candidate found'}`);
                            if (bestSecondary?.secondary_fit) {
                                flagWarnings.push(`   Reason: ${bestSecondary.secondary_fit}`);
                            }
                        }

                        // Mark reference as needing manual review if there are warnings
                        ref.needsManualReview = flagWarnings.length > 0;

                        // Enhanced debug logging for manual review cases
                        if (ref.needsManualReview) {
                            const reviewReasons = [];
                            if (!bestPrimary || bestPrimary.primary_score < 75) {
                                reviewReasons.push(`Primary score: ${bestPrimary?.primary_score || 0}`);
                            }
                            if (!bestSecondary || bestSecondary.secondary_score < 75) {
                                reviewReasons.push(`Secondary score: ${bestSecondary?.secondary_score || 0}`);
                            }
                            this.addDebugLog(`‚ö†Ô∏è Manual review required: ${reviewReasons.join(', ')}`);
                        }

                        // Auto-fill top URLs from ranked results (even if scores are low, so user can review)
                        if (bestPrimary) {
                            const topCandidate = ref.searchResults[bestPrimary.index];
                            if (topCandidate) {
                                ref.urls.primary = topCandidate.url;
                                document.getElementById('editPrimaryUrl').value = topCandidate.url;

                                // Add warning badge if score is low
                                const warningBadge = bestPrimary.primary_score <= 60 ?
                                    ' <span style="background: var(--warning-color); color: white; padding: 0.2rem 0.5rem; border-radius: 4px; font-size: 0.75rem;">‚ö†Ô∏è LOW SCORE</span>' : '';

                                document.getElementById('displayPrimaryUrl').innerHTML = `<a href="${topCandidate.url}" target="_blank" style="color: var(--success-color); text-decoration: none;">${topCandidate.url}</a>${warningBadge}`;
                                this.addDebugLog(`Primary URL (P:${bestPrimary.primary_score}, S:${bestPrimary.secondary_score}): ${topCandidate.url}`);
                                this.aiRankedResults.primary = topCandidate.url;
                            }
                        } else {
                            // No primary found
                            document.getElementById('editPrimaryUrl').value = '';
                            document.getElementById('displayPrimaryUrl').innerHTML = '<span style="color: var(--warning-color);">‚ö†Ô∏è No suitable primary URL found</span>';
                        }

                        if (bestSecondary && bestSecondary.index !== bestPrimary?.index) {
                            const secondCandidate = ref.searchResults[bestSecondary.index];
                            if (secondCandidate) {
                                ref.urls.secondary = secondCandidate.url;
                                document.getElementById('editSecondaryUrl').value = secondCandidate.url;

                                // Add warning badge if score is low
                                const warningBadge = bestSecondary.secondary_score <= 60 ?
                                    ' <span style="background: var(--warning-color); color: white; padding: 0.2rem 0.5rem; border-radius: 4px; font-size: 0.75rem;">‚ö†Ô∏è LOW SCORE</span>' : '';

                                document.getElementById('displaySecondaryUrl').innerHTML = `<a href="${secondCandidate.url}" target="_blank" style="color: var(--accent-color); text-decoration: none;">${secondCandidate.url}</a>${warningBadge}`;
                                this.addDebugLog(`Secondary URL (P:${bestSecondary.primary_score}, S:${bestSecondary.secondary_score}): ${secondCandidate.url}`);
                                this.aiRankedResults.secondary = secondCandidate.url;
                            }
                        } else {
                            // No secondary found
                            document.getElementById('editSecondaryUrl').value = '';
                            document.getElementById('displaySecondaryUrl').innerHTML = '<span style="color: var(--warning-color);">‚ö†Ô∏è No suitable secondary URL found</span>';
                        }

                        // Show warning panel if there are flags
                        if (flagWarnings.length > 0) {
                            const warningContent = flagWarnings.join('\n');
                            this.addDebugPanel('‚ö†Ô∏è URL Selection Flags', warningContent, 'warning');
                            this.showToast('‚ö†Ô∏è Manual review required - check Debug tab', 'warning');
                        }

                        // Store rankings for the reference
                        ref.rankings = response.rankings;

                        // Render candidates using the new function (supports sort toggle)
                        this.renderCandidates(ref.searchResults, response.rankings);

                        // Add debug panel for autorank results
                        const primaryUrl = bestPrimary ? ref.searchResults[bestPrimary.index]?.url || 'N/A' : 'N/A';
                        const secondaryUrl = bestSecondary ? ref.searchResults[bestSecondary.index]?.url || 'N/A' : 'N/A';

                        let searchInfo = '';
                        if (response.searches_performed && response.searches_performed > 0) {
                            searchInfo = `\n<strong>üîç AI Searches Performed:</strong> ${response.searches_performed}\n<strong>Total Candidates:</strong> ${ref.searchResults.length} (${response.searches_performed > 0 ? `+${ref.searchResults.length - candidates.length} from AI` : 'original'})\n`;
                        }

                        // v14.2: Add cost information
                        let costInfo = '';
                        if (response.input_tokens && response.output_tokens) {
                            this.trackClaudeRank(response.input_tokens, response.output_tokens);
                            const cost = ((response.input_tokens / 1000) * 0.003) + ((response.output_tokens / 1000) * 0.015);
                            costInfo = `\n<strong>Tokens:</strong> ${response.input_tokens.toLocaleString()} input + ${response.output_tokens.toLocaleString()} output
<strong>Cost:</strong> $${cost.toFixed(4)}`;
                        }

                        const panelContent = `<strong>Candidates Ranked:</strong> ${response.rankings.length}${searchInfo}

<strong>Primary Recommendation:</strong>
URL: ${primaryUrl}
Primary Score: ${bestPrimary?.primary_score || 'N/A'}
Secondary Score: ${bestPrimary?.secondary_score || 'N/A'}
Combined Score: ${bestPrimary?.combined_score || 'N/A'}
${bestPrimary?.title_match ? `Title Match: ${bestPrimary.title_match}` : ''}
${bestPrimary?.author_match !== undefined ? `Author Match: ${bestPrimary.author_match}` : ''}

<strong>Secondary Recommendation:</strong>
URL: ${secondaryUrl}
Primary Score: ${bestSecondary?.primary_score || 'N/A'}
Secondary Score: ${bestSecondary?.secondary_score || 'N/A'}
Combined Score: ${bestSecondary?.combined_score || 'N/A'}${costInfo}`;
                        this.addDebugPanel('Autorank Results', panelContent, 'success');

                        // v14.2: Add cumulative cost panel after autorank
                        this.addCostSummaryPanel();

                        this.showToast('URLs ranked and auto-filled', 'success');
                    } else if (response.error) {
                        // Enhanced error panel with full details
                        let errorDetails = `<strong>Error:</strong> ${response.error}\n\n`;

                        if (response.raw_response_preview) {
                            errorDetails += `<strong>AI Response Preview:</strong>\n${response.raw_response_preview}\n\n`;
                        }

                        if (response.allCandidates) {
                            errorDetails += `<strong>Candidates Sent:</strong> ${response.allCandidates.length}\n`;
                        }

                        if (response.searches_performed !== undefined) {
                            errorDetails += `<strong>Searches Performed:</strong> ${response.searches_performed}\n`;
                        }

                        this.addDebugPanel('Ranking API Error', errorDetails, 'error');
                        this.showToast('Ranking failed: ' + response.error.substring(0, 100), 'error');
                    } else {
                        this.addDebugLog('No rankings returned from API');
                        this.showToast('No rankings returned', 'warning');
                    }
                } catch (error) {
                    const errorMsg = error.message || error.toString();
                    const errorType = error.name || 'Unknown';

                    let debugInfo = `<strong>Error Type:</strong> ${errorType}\n`;
                    debugInfo += `<strong>Error Message:</strong> ${errorMsg}\n`;

                    if (error.stack) {
                        debugInfo += `\n<strong>Stack Trace:</strong>\n${error.stack.substring(0, 500)}`;
                    }

                    this.addDebugPanel('Exception: Autorank Failed', debugInfo, 'error');

                    // Specific error message based on type
                    if (errorMsg.includes('fetch failed') || errorMsg.includes('network')) {
                        this.showToast('Network error during ranking. Check connection and retry.', 'error');
                    } else if (errorMsg.includes('timeout') || errorMsg.includes('abort')) {
                        this.showToast('Ranking timeout. Try with fewer candidates or simpler queries.', 'error');
                    } else {
                        this.showToast('Ranking failed. Check Debug tab (Tab 3) for details.', 'error');
                    }

                    console.error('Ranking error:', error);
                } finally {
                    btn.disabled = false;
                    document.getElementById('rankBtnText').textContent = originalText;
                }
            },

            // Debug Panel System
            addDebugPanel(title, content, type = '') {
                const timestamp = new Date().toLocaleTimeString();

                // Check if we should consolidate with existing System Log panel
                if (title === 'System Log' && this.currentSystemLogPanel) {
                    // Append to existing system log panel
                    const contentDiv = this.currentSystemLogPanel.querySelector('.debug-panel-content');
                    if (contentDiv) {
                        contentDiv.innerHTML += '\n' + content;
                    }

                    // Update the panel data in our array
                    const lastPanel = this.debugPanels[this.debugPanels.length - 1];
                    if (lastPanel && lastPanel.title === 'System Log') {
                        lastPanel.content += '\n' + content;
                    }

                    // Save to session log
                    this.saveToSessionLog({timestamp, title, content, type});
                } else {
                    // Create new panel
                    const panel = {
                        timestamp,
                        title,
                        content,
                        type
                    };

                    this.debugPanels.push(panel);
                    this.renderDebugPanel(panel);

                    // If this is a System Log, track it for future consolidation
                    if (title === 'System Log') {
                        const container = document.getElementById('debugPanelsContainer');
                        this.currentSystemLogPanel = container?.lastElementChild;
                    } else {
                        // Different panel type resets the system log consolidation
                        this.currentSystemLogPanel = null;
                    }

                    // Save to session log
                    this.saveToSessionLog(panel);
                }

                // Auto-scroll to latest panel
                setTimeout(() => {
                    const container = document.getElementById('debugPanelsContainer');
                    if (container) {
                        container.scrollTop = container.scrollHeight;
                    }
                }, 100);
            },

            renderDebugPanel(panel) {
                const container = document.getElementById('debugPanelsContainer');
                if (!container) return;

                const panelDiv = document.createElement('div');
                panelDiv.className = `debug-panel ${panel.type}`;
                panelDiv.innerHTML = `
                    <div class="debug-panel-header">
                        <span>${panel.title}</span>
                        <span class="debug-panel-timestamp">${panel.timestamp}</span>
                    </div>
                    <div class="debug-panel-content">${panel.content}</div>
                `;
                container.appendChild(panelDiv);
            },

            initializeDebugPanels(ref) {
                this.debugPanels = [];
                this.currentSystemLogPanel = null;  // Reset consolidation tracker
                const container = document.getElementById('debugPanelsContainer');
                if (!container) return;
                container.innerHTML = '';

                // Panel 1: Raw Reference
                const rawContent = `${ref.sourceLine || '[No raw data available]'}`;
                this.addDebugPanel('Raw Reference from decisions.txt', rawContent);

                // Panel 2: Parsed Reference
                const parsedContent = `<strong>ID:</strong> ${ref.id}
<strong>Title:</strong> ${ref.title || 'N/A'}
<strong>Authors:</strong> ${ref.authors || 'N/A'}
<strong>Year:</strong> ${ref.year || 'N/A'}
<strong>Other:</strong> ${ref.other || 'N/A'}
<strong>Primary URL:</strong> ${ref.urls.primary || 'Not set'}
<strong>Secondary URL:</strong> ${ref.urls.secondary || 'Not set'}
<strong>Queries:</strong> ${ref.queries.length} queries loaded`;
                this.addDebugPanel('Parsed Reference Fields', parsedContent);
            },

            saveToSessionLog(panel) {
                const sessionLog = JSON.parse(localStorage.getItem('rr_session_log') || '[]');
                const logEntry = {
                    referenceId: this.currentEditId,
                    timestamp: panel.timestamp,
                    title: panel.title,
                    content: panel.content,
                    type: panel.type
                };
                sessionLog.push(logEntry);
                localStorage.setItem('rr_session_log', JSON.stringify(sessionLog));

                // Update the session log textarea if it exists
                this.updateSessionLogTextarea();
            },

            updateSessionLogTextarea() {
                const textarea = document.getElementById('sessionLogTextarea');
                if (!textarea) return;

                const sessionLog = JSON.parse(localStorage.getItem('rr_session_log') || '[]');

                // Format log for display
                let logContent = `Reference Refinement Session Log\n`;
                logContent += `Total Entries: ${sessionLog.length}\n`;
                logContent += `=`.repeat(80) + `\n\n`;

                let currentRef = null;
                sessionLog.forEach(entry => {
                    if (entry.referenceId !== currentRef) {
                        currentRef = entry.referenceId;
                        logContent += `\n` + `=`.repeat(80) + `\n`;
                        logContent += `REFERENCE ID: ${currentRef}\n`;
                        logContent += `=`.repeat(80) + `\n\n`;
                    }

                    logContent += `[${entry.timestamp}] ${entry.title}\n`;
                    logContent += `-`.repeat(80) + `\n`;
                    // Strip HTML tags from content for plain text display
                    const plainContent = entry.content.replace(/<[^>]*>/g, '').replace(/&nbsp;/g, ' ');
                    logContent += `${plainContent}\n\n`;
                });

                textarea.value = logContent;
            },

            copySessionLog() {
                const textarea = document.getElementById('sessionLogTextarea');
                if (!textarea || !textarea.value) {
                    this.showToast('No session log to copy', 'warning');
                    return;
                }

                textarea.select();
                document.execCommand('copy');
                this.showToast('Session log copied to clipboard! Paste it into a file in Dropbox.', 'success');
            },

            clearSessionLog() {
                const sessionLog = JSON.parse(localStorage.getItem('rr_session_log') || '[]');

                if (sessionLog.length === 0) {
                    this.showToast('Session log is already empty', 'info');
                    return;
                }

                if (confirm(`Clear session log with ${sessionLog.length} entries? This cannot be undone.`)) {
                    localStorage.removeItem('rr_session_log');
                    this.updateSessionLogTextarea();
                    this.showToast('Session log cleared', 'success');
                }
            },

            downloadDecisions() {
                // Export decisions.txt from localStorage
                this.exportFile();
            },

            downloadDebugLog() {
                const sessionLog = JSON.parse(localStorage.getItem('rr_session_log') || '[]');

                if (sessionLog.length === 0) {
                    this.showToast('No debug log data to download', 'warning');
                    return;
                }

                // Format log file
                let logContent = `Reference Refinement Debug Log\n`;
                logContent += `Generated: ${new Date().toLocaleString()}\n`;
                logContent += `Total Entries: ${sessionLog.length}\n`;
                logContent += `=`.repeat(80) + `\n\n`;

                let currentRef = null;
                sessionLog.forEach(entry => {
                    if (entry.referenceId !== currentRef) {
                        currentRef = entry.referenceId;
                        logContent += `\n` + `=`.repeat(80) + `\n`;
                        logContent += `REFERENCE ID: ${currentRef}\n`;
                        logContent += `=`.repeat(80) + `\n\n`;
                    }

                    logContent += `[${entry.timestamp}] ${entry.title}\n`;
                    logContent += `-`.repeat(80) + `\n`;
                    logContent += `${entry.content}\n\n`;
                });

                // Download file
                const blob = new Blob([logContent], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                a.download = `debug_log_${timestamp}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                // Clear log after download
                localStorage.removeItem('rr_session_log');
                this.showToast('Debug log downloaded and cleared', 'success');
            },

            addDebugLog(message) {
                // Backward compatibility - convert old log calls to panels
                this.addDebugPanel('System Log', message);
            },

            saveUserNote() {
                // Auto-save user notes to session log
                clearTimeout(this.userNoteTimeout);
                this.userNoteTimeout = setTimeout(() => {
                    const textarea = document.getElementById('userNotesTextarea');
                    if (!textarea) return;

                    const note = textarea.value.trim();
                    if (!note) return;

                    // Save to session log with special type
                    const timestamp = new Date().toLocaleTimeString();
                    this.saveToSessionLog({
                        timestamp,
                        title: 'üìù User Note',
                        content: note,
                        type: 'USER_NOTE'
                    });
                }, 1000); // Debounce for 1 second
            },

            // v16.5: Quick Note Modal Functions
            showQuickNote() {
                const modal = document.getElementById('quickNoteModal');
                const textarea = document.getElementById('quickNoteTextarea');
                modal.classList.add('show');
                textarea.value = '';
                setTimeout(() => textarea.focus(), 100);
            },

            hideQuickNote() {
                const modal = document.getElementById('quickNoteModal');
                modal.classList.remove('show');
            },

            saveQuickNote() {
                const textarea = document.getElementById('quickNoteTextarea');
                const note = textarea.value.trim();

                if (!note) {
                    this.hideQuickNote();
                    return;
                }

                // Gather full app context
                const context = {
                    currentTab: document.querySelector('.tab-btn.active')?.textContent.trim() || 'Unknown',
                    activeReference: this.selectedReference ? {
                        id: this.selectedReference.id,
                        title: this.selectedReference.title || 'Untitled',
                        finalized: this.selectedReference.finalized || false
                    } : null,
                    editModalOpen: document.getElementById('editModal')?.style.display === 'flex',
                    totalReferences: this.references.length,
                    finalizedCount: this.references.filter(r => r.finalized).length
                };

                // Build context string
                let contextStr = '';
                if (context.activeReference) {
                    contextStr += `Reference: [${context.activeReference.id}] ${context.activeReference.title}\n`;
                    contextStr += `Status: ${context.activeReference.finalized ? 'Finalized' : 'Unfinalized'}\n`;
                }
                contextStr += `Tab: ${context.currentTab}\n`;
                if (context.editModalOpen) contextStr += `Edit Modal: Open\n`;
                contextStr += `Total Refs: ${context.totalReferences} (${context.finalizedCount} finalized)`;

                // Save immediately to session log with full context
                const timestamp = new Date().toLocaleTimeString();
                this.saveToSessionLog({
                    timestamp,
                    title: 'üìù Quick Note',
                    content: `${note}\n\n--- Context ---\n${contextStr}`,
                    type: 'QUICK_NOTE',
                    context: context
                });

                // Show confirmation toast
                this.showToast('Note saved with context!', 'success');

                // Close modal
                this.hideQuickNote();
            },

            // ===== v15.0: ROBUST FILE INTEGRITY SYSTEM =====

            // File locking to prevent concurrent saves
            saveInProgress: false,

            // Escape special characters in text to prevent parsing corruption
            escapeText(text) {
                if (!text) return '';
                return text
                    .replace(/\\/g, '\\\\')   // Backslash must be first
                    .replace(/\[/g, '\\[')    // Left bracket
                    .replace(/\]/g, '\\]')    // Right bracket
                    .replace(/\n/g, '\\n')    // Newlines
                    .replace(/\r/g, '\\r');   // Carriage returns
            },

            // Unescape special characters when parsing
            unescapeText(text) {
                if (!text) return '';
                return text
                    .replace(/\\r/g, '\r')    // Carriage returns
                    .replace(/\\n/g, '\n')    // Newlines
                    .replace(/\\\]/g, ']')    // Right bracket
                    .replace(/\\\[/g, '[')    // Left bracket
                    .replace(/\\\\/g, '\\');  // Backslash must be last
            },

            // Calculate SHA-256 checksum for content verification
            async calculateChecksum(content) {
                const encoder = new TextEncoder();
                const data = encoder.encode(content);
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                return hashHex;
            },

            // Get list of backup files and their timestamps
            async listBackups() {
                if (!this.dropboxClient) return [];

                try {
                    await this.ensureValidDropboxToken();
                    const response = await this.dropboxClient.filesListFolder({ path: '' });

                    const backups = response.result.entries
                        .filter(entry => entry.name.startsWith('decisions_backup_') && entry.name.endsWith('.txt'))
                        .map(entry => ({
                            name: entry.name,
                            path: entry.path_lower,
                            modified: entry.server_modified
                        }))
                        .sort((a, b) => new Date(b.modified) - new Date(a.modified)); // Newest first

                    return backups;
                } catch (error) {
                    console.error('Failed to list backups:', error);
                    return [];
                }
            },

            // Clean up old backups, keeping only the 5 most recent
            async rotateBackups() {
                const backups = await this.listBackups();

                if (backups.length <= 5) {
                    console.log(`[BACKUP] ${backups.length} backups found, no rotation needed`);
                    return;
                }

                console.log(`[BACKUP] ${backups.length} backups found, deleting oldest ${backups.length - 5}`);

                // Delete backups beyond the 5 most recent
                for (let i = 5; i < backups.length; i++) {
                    try {
                        await this.dropboxClient.filesDeleteV2({ path: backups[i].path });
                        console.log(`[BACKUP] Deleted old backup: ${backups[i].name}`);
                    } catch (error) {
                        console.error(`[BACKUP] Failed to delete ${backups[i].name}:`, error);
                    }
                }
            },

            // Create timestamped backup before saving
            async createBackup(content) {
                if (!this.dropboxClient) {
                    console.warn('[BACKUP] Skipping backup - not connected to Dropbox');
                    return false;
                }

                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').split('T')[0] + 'T' +
                                  new Date().toISOString().replace(/[:.]/g, '-').split('T')[1].substring(0, 8);
                const backupPath = `/decisions_backup_${timestamp}.txt`;

                try {
                    await this.ensureValidDropboxToken();
                    await this.dropboxClient.filesUpload({
                        path: backupPath,
                        contents: content,
                        mode: 'add',
                        autorename: false
                    });
                    console.log(`[BACKUP] Created backup: ${backupPath}`);

                    // Rotate old backups in background (don't wait)
                    this.rotateBackups().catch(err => console.error('[BACKUP] Rotation failed:', err));

                    return true;
                } catch (error) {
                    console.error('[BACKUP] Failed to create backup:', error);
                    return false;
                }
            },

            // Retry logic with exponential backoff
            async retryOperation(operation, maxRetries = 3, initialDelay = 1000) {
                let lastError;

                for (let attempt = 1; attempt <= maxRetries; attempt++) {
                    try {
                        return await operation();
                    } catch (error) {
                        lastError = error;

                        if (attempt < maxRetries) {
                            const delay = initialDelay * Math.pow(2, attempt - 1);
                            console.warn(`[RETRY] Attempt ${attempt} failed, retrying in ${delay}ms...`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                        }
                    }
                }

                throw lastError;
            },

            // Utility
            clearAll() {
                if (confirm('Clear all references? This cannot be undone.')) {
                    this.references = [];
                    this.finalizedReferences = [];
                    this.filteredReferences = [];
                    this.renderReferences();
                    this.updateStats();
                    this.showToast('All references cleared', 'success');
                }
            },

            // Notifications
            showToast(message, type = 'info') {
                const container = document.getElementById('toastContainer');
                const toast = document.createElement('div');
                toast.className = `toast ${type}`;

                // Create message span
                const messageSpan = document.createElement('span');
                messageSpan.className = 'toast-message';
                messageSpan.textContent = message;

                // Create close button
                const closeBtn = document.createElement('button');
                closeBtn.className = 'toast-close';
                closeBtn.innerHTML = '&times;';
                closeBtn.setAttribute('aria-label', 'Close notification');
                closeBtn.onclick = () => {
                    toast.classList.remove('visible');
                    setTimeout(() => toast.remove(), 300);
                };

                toast.appendChild(messageSpan);
                toast.appendChild(closeBtn);
                container.appendChild(toast);

                setTimeout(() => toast.classList.add('visible'), 10);

                // Auto-dismiss only success messages after 5 seconds
                // Warning and error messages stay until manually dismissed
                if (type === 'success' || type === 'info') {
                    setTimeout(() => {
                        toast.classList.remove('visible');
                        setTimeout(() => toast.remove(), 300);
                    }, 5000);
                }
            },

            // Dropbox Integration
            async handleDropboxOAuthCallback() {
                // Check for authorization code (PKCE Flow)
                const urlParams = new URLSearchParams(window.location.search);
                const code = urlParams.get('code');
                const state = urlParams.get('state');
                const error = urlParams.get('error');
                const errorDescription = urlParams.get('error_description');

                // Check if Dropbox returned an error
                if (error) {
                    console.error('[DROPBOX] OAuth error:', error, errorDescription);
                    window.history.replaceState({}, document.title, window.location.pathname);
                    this.showToast(`Dropbox OAuth error: ${error}${errorDescription ? ' - ' + errorDescription : ''}`, 'error');
                    return;
                }

                if (code) {
                    console.log('[DROPBOX] Authorization code received, exchanging for tokens...');

                    // Retrieve the PKCE verifier from state parameter
                    let codeVerifier = null;
                    let source = 'none';

                    if (state && state.startsWith('pkce:')) {
                        // Extract verifier from state parameter
                        codeVerifier = state.substring(5); // Remove "pkce:" prefix
                        source = 'state parameter';
                        console.log('[DROPBOX] PKCE verifier retrieved from state parameter');
                    } else {
                        // Fallback: try old storage methods (for backwards compatibility)
                        console.warn('[DROPBOX] State parameter missing, trying storage fallback...');

                        codeVerifier = this.getCookie('rr_pkce_verifier');
                        if (codeVerifier) source = 'cookie';

                        if (!codeVerifier) {
                            codeVerifier = sessionStorage.getItem('rr_pkce_verifier');
                            if (codeVerifier) source = 'sessionStorage';
                        }

                        if (!codeVerifier) {
                            codeVerifier = localStorage.getItem('rr_pkce_verifier');
                            if (codeVerifier) source = 'localStorage';
                        }
                    }

                    if (!codeVerifier) {
                        console.error('[DROPBOX] PKCE verifier not found in state parameter or storage');
                        window.history.replaceState({}, document.title, window.location.pathname);
                        this.showToast('OAuth error: PKCE verifier missing. Please try connecting again.', 'error');
                        return;
                    }

                    console.log('[DROPBOX] PKCE verifier retrieved successfully from', source);

                    try {
                        // Exchange code for tokens via our Netlify Function
                        const response = await this.apiRequest('/api/dropbox-oauth', {
                            method: 'POST',
                            body: JSON.stringify({
                                code: code,
                                code_verifier: codeVerifier
                            })
                        });

                        if (response.access_token) {
                            // Store tokens
                            this.dropboxAccessToken = response.access_token;
                            this.dropboxRefreshToken = response.refresh_token;
                            this.dropboxTokenExpiry = Date.now() + (response.expires_in * 1000);

                            localStorage.setItem('rr_dropbox_token', response.access_token);
                            localStorage.setItem('rr_dropbox_refresh_token', response.refresh_token);
                            localStorage.setItem('rr_dropbox_token_expiry', this.dropboxTokenExpiry.toString());

                            this.initializeDropbox(response.access_token);

                            // Clean up URL (remove ?code= and ?state= parameters)
                            window.history.replaceState({}, document.title, window.location.pathname);

                            console.log('[DROPBOX] Successfully connected! Token expires in', response.expires_in, 'seconds');

                            // Load fresh data from Dropbox after successful connection
                            console.log('[DROPBOX] Loading fresh data from Dropbox after reconnection...');
                            try {
                                const content = await this.loadFromDropbox('/decisions.txt');
                                if (content) {
                                    console.log('[DROPBOX] Loaded decisions.txt from Dropbox, size:', content.length);

                                    // Clear stale localStorage to prevent future conflicts
                                    localStorage.removeItem('rr_decisions_backup');
                                    localStorage.removeItem('rr_decisions_timestamp');
                                    console.log('[DROPBOX] Cleared stale localStorage backup');

                                    // Parse and render fresh data
                                    this.parseDecisions(content);
                                    this.applyFilters();

                                    // Update localStorage with fresh data
                                    localStorage.setItem('rr_decisions_backup', content);
                                    localStorage.setItem('rr_decisions_timestamp', new Date().toISOString());

                                    this.showToast('Connected to Dropbox and loaded latest data!', 'success');
                                    console.log('[DROPBOX] Successfully loaded and displayed fresh data from Dropbox');
                                } else {
                                    console.log('[DROPBOX] No content in decisions.txt, showing connection success only');
                                    this.showToast('Connected to Dropbox! Your tokens will auto-refresh.', 'success');
                                }
                            } catch (e) {
                                console.error('[DROPBOX] Failed to load data after reconnection:', e);
                                this.showToast('Connected to Dropbox but failed to load data. Try refreshing the page.', 'warning');
                            }
                        } else {
                            throw new Error(response.error || 'Failed to exchange code for tokens');
                        }
                    } catch (error) {
                        console.error('[DROPBOX] Token exchange failed:', error);

                        // Clean up URL on error
                        window.history.replaceState({}, document.title, window.location.pathname);

                        this.showToast('Failed to connect to Dropbox: ' + error.message + '. Please try again.', 'error');
                    }
                }
            },

            initializeDropbox(accessToken) {
                this.dropboxAccessToken = accessToken;
                this.dropboxClient = new Dropbox.Dropbox({ accessToken });
                this.updateDropboxUI(true);
            },

            async connectDropbox() {
                // Generate PKCE code verifier and challenge
                const codeVerifier = this.generateCodeVerifier();
                const codeChallenge = await this.generateCodeChallenge(codeVerifier);

                console.log('[DROPBOX] Initiating PKCE OAuth flow with state parameter');

                // Encode verifier in OAuth state parameter (survives Safari redirects)
                const stateWithVerifier = `pkce:${codeVerifier}`;

                // Use PKCE flow (required for public clients)
                const redirectUri = 'https://rrv521-1760738877.netlify.app/rr_v60.html';
                const authUrl = `https://www.dropbox.com/oauth2/authorize?client_id=${this.dropboxAppKey}&response_type=code&redirect_uri=${encodeURIComponent(redirectUri)}&token_access_type=offline&code_challenge=${codeChallenge}&code_challenge_method=S256&state=${encodeURIComponent(stateWithVerifier)}`;

                console.log('[DROPBOX] Redirecting to Dropbox for authorization');
                window.location.href = authUrl;
            },

            getCookie(name) {
                const value = `; ${document.cookie}`;
                const parts = value.split(`; ${name}=`);
                if (parts.length === 2) return parts.pop().split(';').shift();
                return null;
            },

            deleteCookie(name) {
                document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`;
            },

            generateCodeVerifier() {
                // Generate a random string for PKCE
                const array = new Uint8Array(32);
                crypto.getRandomValues(array);
                return btoa(String.fromCharCode.apply(null, Array.from(array)))
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
                    .replace(/=/g, '');
            },

            async generateCodeChallenge(verifier) {
                // Hash the verifier using SHA-256
                const encoder = new TextEncoder();
                const data = encoder.encode(verifier);
                const hash = await crypto.subtle.digest('SHA-256', data);
                return btoa(String.fromCharCode.apply(null, Array.from(new Uint8Array(hash))))
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
                    .replace(/=/g, '');
            },

            disconnectDropbox() {
                this.dropboxAccessToken = null;
                this.dropboxRefreshToken = null;
                this.dropboxTokenExpiry = null;
                this.dropboxClient = null;
                localStorage.removeItem('rr_dropbox_token');
                localStorage.removeItem('rr_dropbox_refresh_token');
                localStorage.removeItem('rr_dropbox_token_expiry');
                this.updateDropboxUI(false);
                this.showToast('Disconnected from Dropbox', 'info');
            },

            async ensureValidDropboxToken() {
                // Check if we need to refresh the token
                // Refresh if token expires in less than 5 minutes
                const fiveMinutes = 5 * 60 * 1000;

                if (!this.dropboxTokenExpiry || !this.dropboxRefreshToken) {
                    console.log('[DROPBOX] No expiry time or refresh token - skipping refresh');
                    return;
                }

                const timeUntilExpiry = this.dropboxTokenExpiry - Date.now();

                if (timeUntilExpiry < fiveMinutes) {
                    console.log('[DROPBOX] Token expires soon, refreshing... (expires in', Math.floor(timeUntilExpiry / 1000), 'seconds)');

                    try {
                        const response = await this.apiRequest('/api/dropbox-oauth', {
                            method: 'POST',
                            body: JSON.stringify({
                                grant_type: 'refresh_token',
                                refresh_token: this.dropboxRefreshToken
                            })
                        });

                        if (response.access_token) {
                            // Update tokens
                            this.dropboxAccessToken = response.access_token;
                            this.dropboxTokenExpiry = Date.now() + (response.expires_in * 1000);

                            // Update refresh token if a new one was provided
                            if (response.refresh_token) {
                                this.dropboxRefreshToken = response.refresh_token;
                                localStorage.setItem('rr_dropbox_refresh_token', response.refresh_token);
                            }

                            localStorage.setItem('rr_dropbox_token', response.access_token);
                            localStorage.setItem('rr_dropbox_token_expiry', this.dropboxTokenExpiry.toString());

                            // Update the Dropbox client with new token
                            if (this.dropboxClient) {
                                this.dropboxClient = new Dropbox.Dropbox({ accessToken: response.access_token });
                            }

                            console.log('[DROPBOX] Token refreshed successfully, new expiry in:', response.expires_in, 'seconds');
                        } else {
                            throw new Error(response.error || 'Failed to refresh token');
                        }
                    } catch (error) {
                        console.error('[DROPBOX] Token refresh failed:', error);
                        this.showToast('Dropbox token refresh failed. Please reconnect.', 'warning');
                        // Don't clear tokens yet - let user reconnect manually
                    }
                } else {
                    console.log('[DROPBOX] Token still valid for', Math.floor(timeUntilExpiry / 60000), 'minutes');
                }
            },

            updateDropboxUI(connected) {
                const btn = document.getElementById('dropboxConnectBtn');
                const status = document.getElementById('dropboxStatus');
                const saveLogBtn = document.getElementById('saveLogBtn');

                if (connected) {
                    btn.textContent = 'Disconnect';
                    btn.onclick = () => this.disconnectDropbox();
                    status.textContent = '‚úì Connected';
                    status.style.color = 'var(--success-color)';
                    if (saveLogBtn) saveLogBtn.disabled = false;
                } else {
                    btn.textContent = 'Connect to Dropbox';
                    btn.onclick = () => this.connectDropbox();
                    status.textContent = 'Not connected';
                    status.style.color = 'var(--text-secondary)';
                    if (saveLogBtn) saveLogBtn.disabled = true;
                }
            },

            async saveToDropbox(path, content) {
                if (!this.dropboxClient) {
                    this.showToast('Not connected to Dropbox', 'error');
                    return false;
                }

                // Ensure token is valid before making request
                await this.ensureValidDropboxToken();

                try {
                    // v15.9: Enhanced debugging for 400 errors
                    console.log('[DROPBOX DEBUG] Save attempt:');
                    console.log('  Path:', path);
                    console.log('  Content length:', content.length, 'bytes');
                    console.log('  Content sample (first 100):', content.substring(0, 100));
                    console.log('  Content sample (last 100):', content.substring(content.length - 100));
                    console.log('  Token present:', !!this.dropboxAccessToken);
                    console.log('  Token length:', this.dropboxAccessToken ? this.dropboxAccessToken.length : 0);

                    // Convert string to Blob to ensure proper UTF-8 encoding
                    // This prevents 400 errors with large files or special characters
                    const blob = new Blob([content], { type: 'text/plain; charset=utf-8' });
                    console.log('  Blob size:', blob.size, 'bytes');
                    console.log('  Blob type:', blob.type);

                    await this.dropboxClient.filesUpload({
                        path: path,
                        contents: blob,
                        mode: 'overwrite',
                        autorename: false
                    });

                    console.log('[DROPBOX DEBUG] Save succeeded!');
                    return true;
                } catch (error) {
                    console.error('[DROPBOX DEBUG] Save failed with full error:');
                    console.error('  error:', error);
                    console.error('  error.status:', error.status);
                    console.error('  error.message:', error.message);
                    console.error('  error.error:', error.error);
                    console.error('  error.response:', error.response);
                    console.error('  Full error JSON:', JSON.stringify(error, null, 2));

                    // Check if this is a 401 (token expired) error
                    if (error.status === 401 || (error.error && error.error.error && error.error.error['.tag'] === 'invalid_access_token')) {
                        // Token expired - auto-disconnect and prompt to reconnect
                        this.dropboxAccessToken = null;
                        this.dropboxClient = null;
                        localStorage.removeItem('rr_dropbox_token');
                        this.updateDropboxUI(false);

                        // Show friendly reconnect prompt
                        const reconnect = confirm('Your Dropbox session has expired. Would you like to reconnect now?');
                        if (reconnect) {
                            this.connectDropbox();
                        }
                        return false;
                    }

                    // v15.9: Show detailed error message for debugging
                    const errorDetails = error.error ? JSON.stringify(error.error) : error.message;
                    this.showToast('Failed to save to Dropbox: ' + errorDetails, 'error');
                    return false;
                }
            },

            async saveDecisionsToDropbox() {
                // v15.0: BULLETPROOF TWO-PHASE COMMIT SAVE
                if (!this.dropboxClient) {
                    this.showToast('Not connected to Dropbox', 'error');
                    return;
                }

                // Check for concurrent save
                if (this.saveInProgress) {
                    this.showToast('Save already in progress, please wait...', 'warning');
                    return;
                }

                this.saveInProgress = true;
                console.log('[SAVE] Starting bulletproof save process...');

                try {
                    // STEP 1: Generate content
                    console.log('[SAVE] Step 1: Generating content...');
                    let content = '';
                    for (const ref of this.references) {
                        content += this.generateDecisionsEntry(ref, ref.finalized) + '\n';
                    }
                    console.log(`[SAVE] Generated ${content.split('\n').length} lines, ${content.length} bytes`);

                    // STEP 2: Validate content by parsing it back
                    console.log('[SAVE] Step 2: Validating content by parsing...');
                    try {
                        const testRefs = [];
                        const lines = content.split('\n');
                        for (const line of lines) {
                            const trimmed = line.trim();
                            if (trimmed.startsWith('[') && trimmed.match(/^\[\d+\]/)) {
                                const idMatch = trimmed.match(/\[(\d+)\]/);
                                if (idMatch) {
                                    const testRef = {
                                        id: idMatch[1],
                                        text: trimmed,
                                        finalized: false,
                                        relevance_text: '',
                                        urls: { primary: '', secondary: '', tertiary: '' },
                                        queries: [], searchResults: [],
                                        title: '', authors: '', year: '',
                                        container_title: '', publisher: '', publisher_place: '',
                                        volume: '', issue: '', pages: '', edition: '',
                                        doi: '', isbn: '', needsManualReview: false
                                    };
                                    this.extractReferenceInfo(testRef);
                                    testRefs.push(testRef);
                                }
                            }
                        }
                        console.log(`[SAVE] Validation passed: Parsed ${testRefs.length} references`);

                        if (testRefs.length !== this.references.length) {
                            throw new Error(`Validation failed: Expected ${this.references.length} refs, parsed ${testRefs.length}`);
                        }
                    } catch (parseError) {
                        console.error('[SAVE] Validation FAILED:', parseError);
                        this.showToast('Generated content failed validation! Save aborted.', 'error');
                        this.saveInProgress = false;
                        return;
                    }

                    // STEP 3: Calculate checksum
                    const expectedChecksum = await this.calculateChecksum(content);
                    console.log(`[SAVE] Step 3: Checksum calculated: ${expectedChecksum.substring(0, 16)}...`);

                    // STEP 4: Create backup of current file (with retry)
                    console.log('[SAVE] Step 4: Creating backup...');
                    try {
                        const currentContent = await this.retryOperation(() => this.loadFromDropbox('/decisions.txt'));
                        if (currentContent) {
                            await this.createBackup(currentContent);
                        }
                    } catch (backupError) {
                        console.warn('[SAVE] Backup failed (non-fatal):', backupError);
                        // Continue - backup failure is not fatal
                    }

                    // STEP 5: Upload to temporary file (with retry)
                    console.log('[SAVE] Step 5: Uploading to temp file...');
                    // Convert string to Blob to ensure proper UTF-8 encoding
                    // This prevents 400 errors with large files or special characters
                    const contentBlob = new Blob([content], { type: 'text/plain; charset=utf-8' });
                    console.log(`[SAVE] Created Blob: ${contentBlob.size} bytes, type: ${contentBlob.type}`);
                    await this.retryOperation(async () => {
                        await this.dropboxClient.filesUpload({
                            path: '/decisions_temp.txt',
                            contents: contentBlob,
                            mode: 'overwrite',
                            autorename: false
                        });
                    });
                    console.log('[SAVE] Temp file uploaded successfully');

                    // STEP 6: Download temp file and verify checksum
                    console.log('[SAVE] Step 6: Verifying temp file...');
                    const verifiedContent = await this.retryOperation(() => this.loadFromDropbox('/decisions_temp.txt'));

                    if (!verifiedContent) {
                        throw new Error('Failed to download temp file for verification');
                    }

                    const actualChecksum = await this.calculateChecksum(verifiedContent);
                    console.log(`[SAVE] Verification checksum: ${actualChecksum.substring(0, 16)}...`);

                    if (expectedChecksum !== actualChecksum) {
                        throw new Error(`Checksum mismatch! Expected: ${expectedChecksum.substring(0, 16)}..., Got: ${actualChecksum.substring(0, 16)}...`);
                    }

                    console.log('[SAVE] Step 7: Checksum verified! Content is intact.');

                    // STEP 8: Commit - Upload verified content to decisions.txt (with retry)
                    console.log('[SAVE] Step 8: Uploading verified content to decisions.txt...');
                    // Convert verified content to Blob for upload
                    const verifiedBlob = new Blob([verifiedContent], { type: 'text/plain; charset=utf-8' });
                    await this.retryOperation(async () => {
                        await this.dropboxClient.filesUpload({
                            path: '/decisions.txt',
                            contents: verifiedBlob,
                            mode: 'overwrite',
                            autorename: false
                        });
                    });
                    console.log('[SAVE] Committed successfully');

                    // STEP 9: Clean up temp file
                    console.log('[SAVE] Step 9: Cleaning up temp file...');
                    try {
                        await this.dropboxClient.filesDeleteV2({ path: '/decisions_temp.txt' });
                    } catch (cleanupError) {
                        console.warn('[SAVE] Temp file cleanup failed (non-fatal):', cleanupError);
                    }

                    // STEP 10: Update localStorage backup
                    localStorage.setItem('rr_decisions_backup', content);
                    localStorage.setItem('rr_decisions_timestamp', new Date().toISOString());

                    console.log('[SAVE] ‚úÖ Save completed successfully!');
                    this.showToast('‚úÖ decisions.txt saved successfully (verified)', 'success');

                } catch (error) {
                    console.error('[SAVE] ‚ùå Save FAILED:', error);
                    this.showToast(`Save failed: ${error.message}`, 'error');

                    // Attempt to clean up temp file
                    try {
                        await this.dropboxClient.filesDeleteV2({ path: '/decisions_temp.txt' });
                    } catch (cleanupError) {
                        // Ignore cleanup errors
                    }
                } finally {
                    this.saveInProgress = false;
                }
            },

            async saveSessionLogToDropbox() {
                if (!this.dropboxClient) {
                    this.showToast('Not connected to Dropbox', 'error');
                    return;
                }

                const sessionLog = JSON.parse(localStorage.getItem('rr_session_log') || '[]');

                if (sessionLog.length === 0) {
                    this.showToast('No session log to save', 'warning');
                    return;
                }

                // Format log file
                let logContent = `Reference Refinement Debug Log\n`;
                logContent += `Generated: ${new Date().toLocaleString()}\n`;
                logContent += `Total Entries: ${sessionLog.length}\n`;
                logContent += `=`.repeat(80) + `\n\n`;

                let currentRef = null;
                sessionLog.forEach(entry => {
                    if (entry.referenceId !== currentRef) {
                        currentRef = entry.referenceId;
                        logContent += `\n` + `=`.repeat(80) + `\n`;
                        logContent += `REFERENCE ID: ${currentRef}\n`;
                        logContent += `=`.repeat(80) + `\n\n`;
                    }

                    logContent += `[${entry.timestamp}] ${entry.title}\n`;
                    logContent += `-`.repeat(80) + `\n`;
                    logContent += `${entry.content}\n\n`;
                });

                // Add override summary section if there are any overrides
                if (this.overrideLog.length > 0) {
                    logContent += `\n\n` + `=`.repeat(80) + `\n`;
                    logContent += `AI OVERRIDE DECISIONS SUMMARY (${this.overrideLog.length} total)\n`;
                    logContent += `=`.repeat(80) + `\n\n`;

                    this.overrideLog.forEach((override, index) => {
                        logContent += `Override #${index + 1}\n`;
                        logContent += `-`.repeat(80) + `\n`;
                        logContent += `Timestamp: ${new Date(override.timestamp).toLocaleString()}\n`;
                        logContent += `Reference ID: ${override.rid}\n`;
                        logContent += `Type: ${override.override_type}\n`;

                        if (override.reference_metadata) {
                            logContent += `\nReference:\n`;
                            logContent += `  Title: ${override.reference_metadata.title}\n`;
                            logContent += `  Authors: ${override.reference_metadata.authors}\n`;
                            logContent += `  Year: ${override.reference_metadata.year}\n`;
                        }

                        if (override.ai_suggested) {
                            logContent += `\nAI Recommended:\n`;
                            logContent += `  URL: ${override.ai_suggested.url}\n`;
                            logContent += `  Primary Score: ${override.ai_suggested.primary_score}\n`;
                            logContent += `  Secondary Score: ${override.ai_suggested.secondary_score}\n`;
                            if (override.ai_suggested.primary_fit) {
                                logContent += `  Fit: ${override.ai_suggested.primary_fit}\n`;
                            }
                        }

                        if (override.user_selected) {
                            logContent += `\nYou Selected:\n`;
                            logContent += `  URL: ${override.user_selected.url}\n`;
                            logContent += `  Primary Score: ${override.user_selected.primary_score}\n`;
                            logContent += `  Secondary Score: ${override.user_selected.secondary_score}\n`;
                            logContent += `  Ranked Position: ${override.user_selected.was_ranked}\n`;
                        }

                        if (override.user_annotation) {
                            logContent += `\nYour Reason:\n`;
                            logContent += `  "${override.user_annotation}"\n`;
                        }

                        logContent += `\n`;
                    });
                }

                // Add session cost summary
                logContent += `\n\n` + `=`.repeat(80) + `\n`;
                logContent += `SESSION COST SUMMARY\n`;
                logContent += `=`.repeat(80) + `\n\n`;
                logContent += `Google API:\n`;
                logContent += `  Searches Executed: ${this.sessionCosts.googleSearches}\n`;
                logContent += `  Cost (at $0.005/query): $${this.calculateGoogleCost()}\n\n`;
                logContent += `Claude API (Sonnet 4):\n`;
                logContent += `  Query Generation: ${this.sessionCosts.claudeQueryGenCalls} calls\n`;
                logContent += `    Input Tokens: ${this.sessionCosts.claudeQueryGenTokensIn.toLocaleString()}\n`;
                logContent += `    Output Tokens: ${this.sessionCosts.claudeQueryGenTokensOut.toLocaleString()}\n`;
                logContent += `  Ranking: ${this.sessionCosts.claudeRankCalls} calls\n`;
                logContent += `    Input Tokens: ${this.sessionCosts.claudeRankTokensIn.toLocaleString()}\n`;
                logContent += `    Output Tokens: ${this.sessionCosts.claudeRankTokensOut.toLocaleString()}\n`;
                logContent += `  Total Tokens: ${(this.sessionCosts.claudeQueryGenTokensIn + this.sessionCosts.claudeRankTokensIn + this.sessionCosts.claudeQueryGenTokensOut + this.sessionCosts.claudeRankTokensOut).toLocaleString()}\n`;
                logContent += `  Cost (at $0.003/1K in, $0.015/1K out): $${this.calculateClaudeCost()}\n\n`;
                logContent += `TOTAL SESSION COST: $${this.calculateTotalSessionCost()}\n`;
                logContent += `=`.repeat(80) + `\n\n`;

                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                const success = await this.saveToDropbox(`/debug_logs/session_${timestamp}.txt`, logContent);

                if (success) {
                    // Clear log after saving
                    localStorage.removeItem('rr_session_log');
                    this.updateSessionLogTextarea();
                    this.showToast('Session log saved to Dropbox and cleared', 'success');
                }
            },

            async loadFromDropbox(path) {
                if (!this.dropboxClient) {
                    return null;
                }

                // Ensure token is valid before making request
                await this.ensureValidDropboxToken();

                try {
                    const response = await this.dropboxClient.filesDownload({ path: path });
                    const blob = response.result.fileBlob;
                    const text = await blob.text();
                    return text;
                } catch (error) {
                    console.error('Dropbox load error:', error);
                    // Don't show error toast on startup - file might not exist yet
                    return null;
                }
            },

            async loadDecisionsFromDropbox() {
                if (!this.dropboxClient) return;

                const content = await this.loadFromDropbox('/decisions.txt');
                if (content) {
                    // Parse and load the content
                    document.getElementById('decisionsInput').value = content;
                    this.parseDecisions();
                    this.showToast('decisions.txt loaded from Dropbox', 'success');
                }
            }
        };

        // Initialize on load
        document.addEventListener('DOMContentLoaded', () => {
            app.init();
        });
    </script>

    <!-- Quick Note Modal -->
    <div id="quickNoteModal" class="quick-note-modal" onclick="if(event.target === this) app.hideQuickNote()">
        <div class="quick-note-content">
            <div class="quick-note-header">
                <span style="font-size: 1.5rem;">üìù</span>
                <h3 style="margin: 0;">Quick Note</h3>
            </div>
            <textarea id="quickNoteTextarea" class="quick-note-textarea"
                placeholder="Type your observation or note here..."></textarea>
            <div class="quick-note-actions">
                <button onclick="app.hideQuickNote()" class="secondary">Cancel</button>
                <button onclick="app.saveQuickNote()" class="primary">Done</button>
            </div>
        </div>
    </div>
</body>
</html>
